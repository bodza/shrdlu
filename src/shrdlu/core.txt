ยง anno/winograd/README

This directory contains the source files for SHRDLU, a program
 written by Terry Winograd at the MIT AI Lab in 1968-1970.  For
 a full description, see Terry Winograd, Understanding Natural
 Language, Academic Press, 1972.

The version here is a cleaned up version done by Stu Card,
 Andee Rubin, and Terry Winograd in 1972.   The files are
 available for anyone who wants to use them (let me know
if you get something running!).

Terry Winograd (winograd@cs.stanford.edu)

--------

Excerpt from the  PROVISIONAL SHRDLU USERS' MANUAL (see file shrdlu/manual):

BRIEF DESCRIPTION OF SHRDLU
---------------------------

         SHRDLU IS A SYSTEM FOR THE  COMPUTER  UNDERSTANDING
    OF  ENGLISH.    THE  SYSTEM  ANSWERS QUESTIONS, EXECUTES
    COMMANDS, AND  ACCEPTS  INFORMATION  IN  NORMAL  ENGLISH
    DIALOG.    IT  USES  SEMANTIC INFORMATION AND CONTEXT TO
    UNDERSTAND DISCOURSE AND TO DISAMBIGUATE SENTENCES.   IT
    COMBINES  A COMPLETE SYNTACTIC ANALYSIS OF EACH SENTENCE
    WITH A "HEURISTIC  UNDERSTANDER"  WHICH  USES  DIFFERENT
    KINDS  OF  INFORMATION  ABOUT A SENTENCE, OTHER PARTS OF
    THE DISCOURSE, AND GENERAL INFORMATION ABOUT  THE  WORLD
    IN DECIDING WHAT THE SENTENCE MEANS.

         SHRDLU  IS  BASED  ON  THE  BELIEF  THAT A COMPUTER
    CANNOT DEAL  REASONABLY  WITH  LANGUAGE  UNLESS  IT  CAN
    "UNDERSTAND"  THE  SUBJECT IT IS DISCUSSING. THE PROGRAM
    IS GIVEN A DETAILED MODEL OF THE KNOWLEDGE NEEDED  BY  A
    SIMPLE  ROBOT  HAVING  ONLY A HAND AND AN EYE.  THE USER
    CAN GIVE IT  INSTRUCTIONS  TO  MANIPULATE  TOY  OBJECTS,
    INTERROGATE  IT ABOUT THE SCENE, AND GIVE IT INFORMATION
    IT WILL USE IN DEDUCTION.  IN ADDITION  TO  KNOWING  THE
    PROPERTIES  OF  TOY  OBJECTS,  THE  PROGRAM HAS A SIMPLE
    MODEL OF  ITS  OWN  MENTALITY.    IT  CAN  REMEMBER  AND
    DISCUSS ITS PLANS AND ACTIONS AS WELL AS CARRY THEM OUT.
    IT ENTERS INTO A DIALOG WITH  A  PERSON,  RESPONDING  TO
    ENGLISH  SENTENCES WITH ACTIONS AND ENGLISH REPLIES, AND
    ASKING FOR CLARIFICATION  WHEN  ITS  HEURISTIC  PROGRAMS
    CANNOT  UNDERSTAND A SENTENCE THROUGH USE OF CONTEXT AND
    PHYSICAL KNOWLEDGE.

         IN THE PROGRAMS, SYNTAX, SEMANTICS,  AND  INFERENCE
    ARE INTEGRATED IN A "VERTICAL" SYSTEM IN WHICH EACH PART
    IS CONSTANTLY COMMUNICATING WITH THE OTHERS. SHRDLU USES
    SYSTEMIC  GRAMMAR, A TYPE OF SYNTACTIC ANALYSIS WHICH IS
    DESIGNED  TO  DEAL  WITH   SEMANTICS.      RATHER   THAN
    CONCENTRATING  ON  THE EXACT FORM OF RULES FOR THE SHAPE
    OF LINGUISTIC  CONSTITUENTS,  IT  IS  STRUCTURED  AROUND
    CHOICES   FOR  CONVEYING  MEANING.    IT  ABSTRACTS  THE
    RELEVANT FEATURES OF THE LINGUISTIC STRUCTURES WHICH ARE
    IMPORTANT FOR INTERPRETING THEIR MEANING.

         IN  SHRDLU  MANY KINDS OF KNOWLEDGE ARE REPRESENTED
    IN THE FORM OF PROCEDURES RATHER THAN TABLES OF RULES OR
    LISTS  OF  PATTERNS.    BY DEVELOPING SPECIAL PROCEDURAL
    LANGUAGES FOR GRAMMAR, SEMANTICS, AND  DEDUCTIVE  LOGIC,
    THE  FLEXIBILITY  AND  POWER OF PROGRAMMING LANGUAGES IS
    GAINED    WHILE    RETAINING    THE    REGULARITY    AND
    UNDERSTANDABILITY  OF SIMPLER RULE FORMS.  EACH PIECE OF
    KNOWLEDGE CAN BE A PROCEDURE, AND CAN CALL ON ANY  OTHER
    PIECE OF KNOWLEDGE IN THE SYSTEM.

IMPLEMENTATION AND VERSION INFORMATION
--------------------------------------

        SHRDLU  WAS  PROGRAMMED  AT   THE   MIT   ARTIFICIAL
    INTELLIGENCE  LABORATORY  BY  T.   WINOGRAD AS PART OF A
    DOCTORAL DISSERTATION IN MATHEMATICS.

        THE PROGRAM WAS MODIFIED DURING THE LAST YEAR BY  T.
    WINOGRAD,  D.  MACDONALD, J. HILL, AND S. CARD TO CHANGE
    SOME OF ITS INTERNAL REPRESENTATIONS  AND  TO  MAKE  THE
    CODE  EASIER  TO UNDERSTAND FOR PERSONS WISHING TO STUDY
    THE PROGRAM.  NO MAJOR ATTEMPTS WERE  MADE  TO  INCREASE
    ITS POWER.

        THE PROGRAM RUNNING AT C-MU IS THE MODIFIED VERSION.
    THE DISPLAY FACILITIES OF  THE  PROGRAM  HAVE  NOT  BEEN
    IMPLEMENTED  AT  C-MU.  THE PROGRAM WAS COAXED AWAY FROM
    MIT'S  INCOMPATIBLE  TIME-SHARING   SYSTEM   (ITS)   AND
    CONVERTED  TO RUN UNDER THE DEC TOPS10 (10-50) OPERATING
    SYSTEM BY CONVERTING MACLISP ITSELF  (AND  TO  DO  THAT,
    CONVERTING  THE  MIDAS  ASSEMBLY LANGUAGE).  THE MACLISP
    CONVERSION WAS DONE BY GEORGE ROBERTSON.

THE VERSION OF SHRDLU BEING DISTRIBUTED FROM  CMU  IS  NAMED
    THE  C1  VERSION.  IT IS CURRENT WITH THE MIT VERSION TO
    JUNE 1972.  THE SHOW AND TELL USER INTERFACE AND VARIOUS
    CHANGES   WERE  ADDED  FOR  THE  C-MU  WORKSHOP  ON  NEW
    TECHNOLOGIES IN COGNITIVE RESEARCH IN JUNE 1972.

        SHRDLU IS  WRITTEN  IN  MACLISP  1.6  (VINTAGE  JUNE
    1972).  IT USES ABOUT 100 TO 140K 36-BIT WORDS OF MEMORY
    ON A PDP-10.

ยง anno/winograd/blurb

    This directory is maintained by Dave McDonald  -DDM  rm.824

-There is no working version of the entire SHRDLU program because
there is no working implementation of MICROPLANNER. Contributions
of same gladly accepted.

-There is, however, a working version of the PROGRAMMAR parser and
grammar that Terry and I developed. It lives as SHRDL1;TS PARSER
and is relatively self-explanitory when started from DDT.

-This directory contains the expr code for the entire SHRDLU system
plus what documentation was ever written and a cross-INDEX'ing.
Requests are often made for the system by people at other instalations
and i send them the contents of this directory

                    7/29/75    -ddm

ยง anno/winograd/demo

(SETQ ERRLIST '((VALRET ':TWDEMO/ )))
(IOC W)
(SETQ PCONSTANT 1)(SETQ PRANDOM 0)
(SETQ WAIT 100)
(SETQ MECONSTANT 1)(SETQ MERANDOM 0)
(SETQ YOUCONSTANT 1)(SETQ YOURANDOM 3)
(SETQ TEXTSIZE 2)
(DISME)(DISYOU)(DTHRU)

@  PICK UP A BIG RED BLOCK.@
(DISME)(FRAME WAIT)
(MOVETO 100 340 500)
(GRASP (QUOTE :B7))
(MOVETO 600 374 200)
(UNGRASP)
(MOVETO 100 440 300)
(GRASP (QUOTE :B6))
(MOVETO 100 440 1000)
(DTHRU)
@  OK.@
(FRAME WAIT)(DISYOU)(DTHRU)
@GRASP THE PYRAMID.@
(DISME)(FRAME WAIT)(DTHRU)
@  I DON'T UNDERSTAND WHICH PYRAMID YOU MEAN.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  FIND A BLOCK WHICH IS TALLER THAN THE ONE YOU ARE HOLDING AND PUT IT INTO THE BOX.@
(DISME)(FRAME WAIT)(DTHRU))
@BY "IT", I ASSUME YOU MEAN THE BLOCK WHICH IS TALLER THAN THE ONE I AM HOLDING.@
(MOVETO 140 600 300) (UNGRASP) (MOVETO 400 700 400) (GRASP (QUOTE :B10)) (MOVETO 700 1100 401) (UNGRASP)(DTHRU)
(DISME)(DTHRU)
@  OK.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  WHAT DOES THE BOX CONTAIN?@
(DISME)(FRAME WAIT)(DTHRU)
@  THE BLUE PYRAMID AND THE BLUE BLOCK.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  WHAT IS THE PYRAMID SUPPORTED BY?@
(DISME)(FRAME WAIT)(DTHRU)
@  THE BOX.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  HOW MANY BLOCKS ARE NOT IN THE BOX?@
(DISME)(FRAME WAIT)(DTHRU)
@ FOUR OF THEM.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  IS AT LEAST ONE OF THEM NARROWER THAN THE ONE WHICH I TOLD YOU TO PICK UP?@
(DISME)(FRAME WAIT)(DTHRU)
@  YES,  THE RED CUBE.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  IS IT SUPPORTED?@
(DISME)(FRAME WAIT)(DTHRU)
@  YES,  BY THE TABLE.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  CAN THE TABLE PICK UP BLOCKS?@
(DISME)(FRAME WAIT)(DTHRU)
@  NO.@
(FRAME WAIT)(DISYOU)(DTHRU)
@CAN A PYRAMID BE SUPPORTED BY A BLOCK?@
(DISME)(FRAME WAIT)(DTHRU)
@  YES.@
(FRAME WAIT)(DISYOU)(DTHRU)
@CAN A PYRAMID SUPPORT A PYRAMID?@
(DISME)(FRAME WAIT)(DTHRU)
@  I DON'T KNOW.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  STACK UP TWO PYRAMIDS.@
(DISME)(FRAME WAIT)(DTHRU)
@  I CAN'T.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  WILL YOU PLEASE STACK UP BOTH OF THE RED BLOCKS AND EITHER A GREEN CUBE OR A PYRAMID?@
(DISME)(FRAME WAIT)
(MOVETO 140 600 300)
(GRASP (QUOTE :B6))
(MOVETO 274 1000 300)
(UNGRASP)
(MOVETO 600 374 200)
(GRASP (QUOTE :B7))
(MOVETO 274 1000 500)
(UNGRASP)
(MOVETO 150 140 200)
(GRASP (QUOTE :B2))
(MOVETO 1000 274 100)
(UNGRASP)
(MOVETO 150 140 100)
(GRASP (QUOTE :B1))
(MOVETO 274 1000 600)
(UNGRASP)
(DTHRU)
@  OK.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  WHICH CUBE IS SITTING ON THE TABLE?@
(DISME)(FRAME WAIT)(DTHRU)
@  THE LARGE GREEN ONE WHICH SUPPORTS THE RED PYRAMID.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  IS THERE A LARGE BLOCK BEHIND A PYRAMID?@
(DISME)(FRAME WAIT)(DTHRU)
@  YES, THREE OF THEM:  A LARGE RED ONE, A LARGE GREEN CUBE, AND THE BLUE ONE.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  PUT A SMALL ONE ONTO THE GREEN CUBE WHICH SUPPORTS A PYRAMID.@
(DISME)(FRAME WAIT)
(GRASP (QUOTE :B1))
(MOVETO 477 40 300)
(UNGRASP)
(DTHRU)
@  OK.@
(FRAME WAIT)(DISYOU)(DTHRU)
@PUT THE LITTLEST PYRAMID ON TOP OF IT.@
(DISME)(FRAME WAIT)
(MOVETO 1000 274 100)
(GRASP (QUOTE :B2))
(MOVETO 477 40 400)
(UNGRASP)
(DTHRU)
@  OK.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  DOES THE SHORTEST THING THE TALLEST PYRAMID'S SUPPORT SUPPORTS SUPPORT ANYTHING GREEN?@
(DISME)(FRAME WAIT)(DTHRU)
@  YES,  THE GREEN PYRAMID.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  WHAT COLOR IS IT?@
(DISME)(FRAME WAIT)(DTHRU)
@BY "IT", I ASSUME YOU MEAN THE SHORTEST THING THE TALLEST PYRAMID'S SUPPORT SUPPORTS.@
(FRAME WAIT) (DISME)(DTHRU)
@  RED@
(FRAME WAIT)(DISYOU)(DTHRU)
@  HOW MANY THINGS ARE ON TOP OF GREEN CUBES?@
(DISME)(FRAME WAIT)(DTHRU)
@  I'M NOT SURE WHAT YOU MEAN BY "ON TOP OF "IN THE PHRASE "ON TOP OF GREEN CUBES "  .
  DO YOU MEAN:
1 - DIRECTLY ON THE SURFACE
2 - ANWHERE ON TOP OF ?@
(FRAME WAIT)(DISAD 'YOU NIL  '/ 2)(DISME)(DTHRU)
@ THREE OF THEM.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  HAD YOU TOUCHED ANY PYRAMID BEFORE YOU PUT THE GREEN ONE ON THE LITTLE CUBE?@
(DISME)(FRAME WAIT)(DTHRU)
@  YES,  THE GREEN ONE.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  WHEN DID YOU PICK IT UP?@
(DISME)(FRAME WAIT)(DTHRU)
@  WHILE I WAS STACKING UP THE RED CUBE, A LARGE RED BLOCK AND A LARGE GREEN CUBE.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  WHY?@
(DISME)(FRAME WAIT)(DTHRU)
@  TO GET RID OF IT.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  WHY DID YOU DO THAT?@
(DISME)(FRAME WAIT)(DTHRU)
@  TO CLEAN OFF THE RED CUBE.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  WHY DID YOU CLEAR OFF THAT CUBE?@
(DISME)(FRAME WAIT)(DTHRU)
@  TO PUT IT ON A LARGE GREEN CUBE.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  WHY DID YOU DO THAT?@
(DISME)(FRAME WAIT)(DTHRU)
@  TO STACK UP THE RED CUBE , A LARGE RED BLOCK AND A LARGE GREEN CUBE.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  WHY DID YOU DO THAT?@
(DISME)(FRAME WAIT)(DTHRU)
@  BECAUSE YOU ASKED ME TO.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  HOW DID YOU DO IT?@
(DISME)(FRAME WAIT)(DTHRU)
@ BY PUTTING A LARGE RED BLOCK ON THE TABLE ; THEN LETTING GO OF IT ; THEN PUTTING A LARGE GREEN CUBE ON IT ; THEN LETTING GO OF THAT CUBE ; THEN PUTTING THE RED CUBE ON THAT CUBE ; THEN LETTING GO OF THAT CUBE.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  HOW MANY OBJECTS DID YOU TOUCH WHILE YOU WERE DOING IT?@
(DISME)(FRAME WAIT)(DTHRU)
@ FOUR OF THEM.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  WHAT DID THE RED CUBE SUPPORT BEFORE YOU STARTED TO CLEAN IT OFF?@
(DISME)(FRAME WAIT)(DTHRU)
@  THE GREEN PYRAMID.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  THERE WERE FIVE BLOCKS TO THE LEFT OF THE BOX THEN.@
(DISME)(FRAME WAIT)(DTHRU)
@ NO, ONLY FOUR OF THEM: THE RED CUBE , TWO LARGE GREEN CUBES AND A LARGE RED BLOCK.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  PUT THE BLUE PYRAMID ON THE BLOCK IN THE BOX.@
(UNGRASP)
(MOVETO 740 740 201)
(GRASP (QUOTE :B4))
(MOVETO 700 1100 601)
(DTHRU)
@  OK.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  IS THERE ANYTHING WHICH IS BIGGER THAN EVERY PYRAMID BUT IS NOT AS WIDE AS THE THING THAT SUPPORTS IT?@
(DISME)(FRAME WAIT)(DTHRU)
@  YES,  THE BLUE BLOCK. @
(FRAME WAIT)(DISYOU)(DTHRU)
@ DOES A STEEPLE@
(DISME)(DTHRU)
@SORRY, I DON'T KNOW THE WORD "STEEPLE".  PLEASE TYPE TWO SPACES.@
LI(DISYOU)(DTHRU)
@  A "STEEPLE" IS A STACK WHICH CONTAINS TWO GREEN CUBES AND A PYRAMID.@
(DISME)(FRAME WAIT)(DTHRU)
@  I UNDERSTAND.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  ARE THERE ANY STEEPLES NOW?@
(DISME)(FRAME WAIT)(DTHRU)
@  NO.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  BUILD ONE.@
(DISME)(FRAME WAIT)
(MOVETO 274 1000 500)
(GRASP (QUOTE :B7))
(MOVETO 200 320 200)
(UNGRASP)
(MOVETO 477 40 400)
(GRASP (QUOTE :B2))
(MOVETO 200 110 100)
(UNGRASP)
(MOVETO 477 40 300)
(GRASP (QUOTE :B1))
(MOVETO 1000 274 100)
(UNGRASP)
(MOVETO 540 140 500)
(GRASP (QUOTE :B5))
(MOVETO 40 500 300)
(UNGRASP)
(MOVETO 500 100 200)
(GRASP (QUOTE :B3))
(MOVETO 200 320 400)
(UNGRASP)
(MOVETO 40 500 300)
(GRASP (QUOTE :B5))
(MOVETO 200 320 700)
(UNGRASP)
(DTHRU)
@  OK.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  CALL THE BIGGEST BLOCK "SUPERBLOCK".@
@  OK.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  HAVE YOU PICKED SUPERBLOCK UP SINCE WE BEGAN?@
(DISME)(FRAME WAIT)(DTHRU)
@  YES.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  WHY DID YOU DROP IT?@
(DISME)(FRAME WAIT)(DTHRU)
@BY "IT", I ASSUME YOU MEAN THE SUPERBLOCK.
 I CAN'T EXPLAIN A NON-EXISTENT EVENT.@
(FRAME WAIT)(DISYOU)(DTHRU)
@  IS THERE ANYTHING TO THE RIGHT OF THE RED PYRAMID?@
(DISME)(FRAME WAIT)(DTHRU)
@ YES, FOUR THINGS:  THE BOX , THE RED CUBE, THE BLUE PYRAMID AND THE BLOCK NAMED SUPERBLOCK@
(FRAME WAIT)(DISYOU)(DTHRU)
@  THANK YOU.@
(DISME)(FRAME WAIT)(DTHRU)
@  YOU'RE WELCOME!@
(AND(READCH)(NOT ^A)(VALRET ':KILL/ ))

ยง anno/winograd/fasl

NET-MAIL-FROM-HOST:1200000013
RETURN-PATH:@SAIL.STANFORD.EDU,@DIAMOND.S4CC.Symbolics.COM:Greenwald@STONY-BROOK.SCRC.Symbolics.COM
TO:"mly-lispm@MC.LCS.MIT.EDU

TEXT;-1
Received: from SAIL.STANFORD.EDU (TCP 1200000013) by MC.LCS.MIT.EDU 22 Dec 86 09:26:46 EST
Received: from [128.81.51.3] by SAIL.STANFORD.EDU with TCP; 22 Dec 86  06:10:54 PST
Received: from SWALLOW.S4CC.Symbolics.COM by DIAMOND.S4CC.Symbolics.COM via CHAOS with CHAOS-MAIL id 39985; Mon 22-Dec-86 09:09:17 EST
Date: Mon, 22 Dec 86 09:08 EST
From: Michael Greenwald <Greenwald@STONY-BROOK.SCRC.Symbolics.COM>
Subject: sharp plus question
To: DCP@QUABBIN.SCRC.Symbolics.COM, DFM%JASPER@LIVE-OAK.LCS.MIT.EDU,
    common-lisp@SU-AI.ARPA
cc: dfm@JASPER.Palladian.COM
In-Reply-To: <861219125356.4.DCP@KOYAANISQATSI.S4CC.Symbolics.COM>
Message-ID: <861222090840.6.GREENWALD@SWALLOW.S4CC.Symbolics.COM>

    Date: Fri, 19 Dec 86 12:53 EST
    From: David C. Plummer <DCP@QUABBIN.SCRC.Symbolics.COM>

    Date: Fri, 19 Dec 86 11:59 EST
    From: Don Morrison <dfm@JASPER.Palladian.COM>

    What should the second form in the following read as?

        (push :mumble *features*)
        '(#-mumble #+mumble 1 2 3)

    I would expect '(2 3).  Both implementations I've tried read '(3), which
    is completely unintuitive to me.  Such a thing can easily come up in real
    life (e.g. commenting out with #+(or) something that's already under
    #+mumble).

                          Don Morrison
                          Palladian Software, Inc.

    This is curious.  In the Symbolics 7.0 implementation,
        '(#+non-existent-feature #-non-existent-feature 1 2 3)
        '(#-non-existent-feature #+non-existent-feature 1 2 3)
        '(#+LISPM #-LISPM 1 2 3)
    each read as '(2 3) but
        '(#-LISPM #+LISPM 1 2 3)
    does read as '(3).  This does seem wrong on the following grounds:
        #-LISPM goes into the mode "read me a form, and ignore it."  It
        recursively invokes the reader.
        The reader gets #+LISPM.  #+LISPM goes into the mode "read
        me a form and don't ignore it."

Currently, the Symbolics' reader treats both #+ and #- as "ignore next
form" when *READ-SUPPRESS* is T.  This is probably a misinterpretation
of *READ-SUPPRESS*.  It was done to solve the problem of an illegally
formed expression following a #+ inside a form with *READ-SUPPRESS* 'T.

For example,
  (PROGN
    #+IMPLEMENTATION-X
    (INCF (FROB-KNOB GROZZLE)
      #+SYS:GREEPS-ALLOWED 3
      #-(CAR FGR:*GROZZLE-MODES*) 2)
    ....)

Is the correct interpretation to obey #+ and #- even inside a
*READ-SUPPRESS*?  (while still suppressing errors inside the feature
specification?)

Clearly #+NON-FEATURE (A B #-NON-FEATURE C), shouldn't cause read errors
while reading C.

The question is whether the internal "feature specification" should be
read with *READ-SUPPRESS* bound specially to NIL or not.
If we keep the current binding of *READ-SUPPRESS*, then feature will
always be NIL (*READ-SUPPRESS* causes all extended tokens to be NIL).
If we bind *READ-SUPPRESS* to NIL to read the feature specification,
then syntactic "errors" in the feature can cause errors.

The problem of supporting (by ignoring) non-standard syntax in feature
specifications doesn't need to be part of COMMON-LISP (I don't think
CL allows extensions there), the question of nested #-'s does need to be
made unambiguous.

Implementations (Symbolics' for example) that want to be generous in
what they accept without error, can handle that themselves.

                        This recursively invokes
        the reader.
            The reader reads 1.
        #+LISPM does not ignore the 1, so it returns it as the thing
        read.
        #-LISPM is given 1 as the result of the read, and ignores it.
        2 and 3 are still in the input stream, so I don't know how both
        of them manage to get ignored.

    [I'm not sure what the current state of our mailer is, but I think mail
    addressed to DFM%JASPER@LIVE-OAK.LCS.MIT.EDU will eventually get to me.]

I'm not on the COMMON-LISP mailing list, but someone from Symbolics can
forward to me any replies, if there is some trouble with the return
paths.

ยง anno/winograd/file-note

Date: Wed, 26 Aug 87 10:39 EDT
From: John C. Mallery <JCMA@AI.AI.MIT.EDU>
Subject: Re: Schrdlu [sic]
To: WINOGRAD@CSLI.STANFORD.EDU
In-Reply-To: The message of 24 Aug 87 18:35 EDT from WINOGRAD@CSLI.STANFORD.EDU
Message-ID: <870826103913.1.JCMA@MORRISON.AI.MIT.EDU>

    Date: Mon 24 Aug 87 15:35:00-PDT
    From: WINOGRAD@CSLI.STANFORD.EDU

    That's very interesting.  In had totally lost track of the files (I
    don't even have a listing!).  Can you give me more info so I can get
    copies of the files?

I include a dired of the directory below.

    I often get requests from people who want a running version, and always
    ask them to let me know if they find one.

Well, I don't know about running.  ITS and Maclisp have both evolved.  You might
be able to find backup versions of the lisp it runs under but ITS changes
would need to be rehacked.  It would probably be simplest to just rewrite
the system in common lisp.  Short of that, you could have somebody rehack
the interface and update the lisp to run in a common lisp.

    And there it was back at MIT all the time! (I had looked on AI, but not
    MC). --t

Well, it was on backup tape and CENT@AI retrieved it for some reason.  Alan
Bawden (Alan@AI.AI.MIT.EDU) can give you substantially more information about
running it again under ITS or finding an old version of Maclisp.  But, it
seems that updating is definitely a better bet.  I would imagine that a
version for PCs might be of value.

So, got any new papers that I want?  Are you going to Hayward's sociology
conference?

MC: SHRDLU; * *
  Free: #0=5733
  251 blocks in the files listed
  0   !THIS! !DIR!     1    142(36)        07/29/75 10:55:35 (04/29/87)   CENT
  0   #FILES 6         2   1373(36)        06/26/74 18:06:52 (08/18/87)   CENT
  0   .MACR  21        1    872(36)        10/20/76 21:02:13 (03/20/86)   CENT
  0   AR0    JAN71    46  47104(36)        05/06/76 22:24:59 (03/20/86)   CENT
  0   AR1    1        17  17408(36)        09/03/77 16:32:41 (03/20/86)   CENT
  0   AR2    1        14  14336(36)        09/03/77 16:28:36 (03/20/86)   CENT
  0   BLOCKL 4         3   2139(36)        11/03/74 13:31:29 (03/20/86)   CENT
  0   BLOCKP 3         5   4817(36)        10/20/76 21:03:25 (03/20/86)   CENT
  0   CGRAM  31       11  11010(36)        10/20/76 22:17:54 (03/20/86)   CENT
  0   DATA   6         1    703(36)        10/20/76 22:18:42 (03/20/86)   CENT
  0   DEMO   FLICK     2   1559(36)        06/22/74 19:40:38 (03/20/86)   CENT
  0   DICTIO 73        9   8643(36)        04/08/73 18:37:12 (03/20/86)   CENT
  0   GINTER 5         1    573(36)        05/07/74 13:47:29 (03/20/86)   CENT
  0   GRAMAR 28       15  14570(36)        06/02/75 14:25:06 (08/18/87)   CENT
  0   GRAPHF FASL      6   5243(36)        05/06/76 22:39:03 (02/27/86)   CENT
  0   GRAPHF STUFF     2   1700(36)        05/06/76 22:38:26 (03/20/86)   CENT
  0   HELP   DOC       2   1190(36)        02/12/73 16:31:57 (08/18/87)   CENT
  0   LISP   USAGE    10  10001(36)        06/26/74 18:23:43 (03/20/86)   CENT
  0   LOADER 18        1    707(36)        01/06/75 14:40:06 (08/18/87)   CENT
  0   MANNEW 2         1    575(36)        04/21/74 16:40:30 (03/20/86)   CENT
  0   MANUAL CMU      14  14209(36)        10/17/72 11:41:38 (06/18/86)   CENT
  0   MINIH  DOC       1    264(36)        02/12/73 16:31:41 (03/20/86)   CENT
  0   MORPHO 13        3   2113(36)        12/31/76 13:10:50 (03/20/86)   CENT
  0   NEWANS 78       10  10105(36)        11/03/74 18:31:01 (03/20/86)   CENT
  0   PARSER 8         3   2378(36)        05/06/76 22:37:40 (08/18/87)   CENT
  0   PLNR   182      16  76934(7)         08/18/87 17:05:39 (08/18/87)   AI0
  0   PROGMR 57        3   3041(36)        06/02/75 14:25:29 (03/20/86)   CENT
  0   SETUP  62        2   1178(36)        11/03/74 13:32:50 (03/20/86)   CENT
  0   SHOW   13        5   4340(36)        11/03/74 13:22:58 (08/18/87)   CENT
  0   SHRDLU (INIT)    1    491(36)        05/26/77 20:24:21 (01/17/87)   CENT
  0   SMASS  19        1    766(36)        11/03/74 13:26:51 (03/20/86)   CENT
  0   SMSPEC 96        7   6894(36)        10/31/76 11:17:05 (03/20/86)   CENT
  0   SMUTIL 148       9   9091(36)        11/03/74 18:10:43 (03/20/86)   CENT
  0   SYSCOM 180       4   3799(36)        12/31/76 13:06:41 (03/20/86)   CENT
  0   THTRAC 22        2   1239(36)        08/30/01 14:41:37 (03/20/86)   CENT
  0   TS     TWDEMO   20  20371(36)        05/06/76 22:36:44 (08/18/87)   CENT

ยง anno/winograd/help

         Instructions for Running SHRDLU

     SHRDLU can be in 4 basic states, COMMAND, READY, RUN,
and REQUEST.  It is initially in READY when loaded.

***
******COMMAND STATE
***

     In this state, SHRDLU expects the user to type a command.
It lets you know this by typing ">>>".
A command is a line containing one or more words, separated by
spaces and terminated by two carriage returns (<CR>).  The first
word must be one of the three words SHOW, TELL, or GO.  The
SHOW command is used to ask the system to show such things
as definitions, structures it is building, and the states of various
parameters and switches.  TELL is used to tell the system new
definitions and settings.
     After executing a COMMAND, the system is ready for
another one, and prompts by saying >>>.
You can leave COMMAND state by typing T,NIL, or $P (<alt mode>-P)
instead of a command.  This will cause the program to continue
whatever it was doing before it entered COMMAND
state, or to go to READY state if it was not already in the
process of analyzing a sentence.  If instead, you type the
command "GO", it will drop the sentence it is working on, and go
into READY state for a new one.
      Of course, the COMMAND state is just a slightly-fudged
LISP listen loop, so you can type any atom or S-expression at it
to be evaluted, go from it into the LISP editor, define new functions,etc.

****
******COMMAND FORMATS
****

     The SHOW and TELL commands are based on  trees
(one tree for each).  The first word of the command is SHOW
or TELL, the second names a node in the corresponding tree,
and the rest are any arguments appropriate to the action
at that node.
For example, the command:

SHOW FUNCTION MEET

will display the contents of the LISP function "MEET".

SHOW SHOW

displays the "SHOW" tree, while for the "TELL" tree, you type

SHOW TELL

     If all of the arguments are not specified, the system will
request more.  For example, typing:
SHOW FUNCTION
would cause it to type out:
FUNCTION:
requesting the name of a function from the user.  It is then
in REQUEST state (see below.)
     Non-terminal nodes of the tree may or may not have corresponding
actions.  For example, the command

TELL PLANNER OFF

causes the entire batch of PLANNER tracing devices to be turned off
at once, even though there are subnodes of the PLANNER node which
can be used to turn individual features on and off selectively.
If there is no action associated with such a node, the system will
ask the user to select one of its subnodes.
     If you type "SHOW" or "TELL" followed by two carriage return,
it will guide you through the choices, using REQUESTS
(see below).
     Typing HELP <CR> <CR> will allow you to see this message or
a shorter version which contains just the most salient details of the four states.

*****
*****REQUEST STATE
*****

     SHRDLU can request two kinds of information from
the user.  If it wants him to CHOOSE between a set of alternatives,
it will end the request with a ?.  If it wants him to SPECIFY
a name or list of names, it will end it with a :.
     For a CHOOSE, all it needs is enough information to decide
between the alternatives.  Begin typing your choice, and when it
is complete enough, type a <period>.  If you type fewer
letters than necessary (e.g. typing just a P, when PLANNER
and PARSING are among the choices) it will do nothing and wait
for you to continue.  If you type more than necessary it doesn't
matter.
     For a SPECIFY, type the required response, terminated by a
<CR>.  If you type a <LF> with nothing else, it will take some
default response which is appropriate to the action (For example,
typing a <LF> in response to a request for which properties of an
atomare to be displayed will have the effect of displaying
all of them.
    For either SPECIFY or CHOOSE, you can get more information on
what is expected by typing a ?<CR>.  It will then give you the
request again.  Typing QUIT<CR> at a "SPECIFY" REQUEST or QUIT
<CR> at a "CHOOSE" REQUEST will cause the entire command
of which it was a part to be discarded without finishing,
returning to COMMAND state.

*****
******READY STATE
*****

     The READY state is entered only when a new English sentence is to
be input.  You can tell you are in it when the sytem types
READY
Respond by typing in an English sentence in normal punctuation
(i.e. ending with a question mark or period).
The system will automatically begin processing it, entering
RUN state.  To get into a COMMAND state while entering a sentence,
type  <alt-mode> <alt-mode>.

*****
******RUN STATE
*****

     Whenever a sentence is input, the system begins to RUN.  It
will stop at selected places, entering COMMAND state so the user can
SHOW things and TELL it things before continuing.  There are various
TELL commands which explain how to change these stopping points.
When a T,NIL, or <alt>-P is typed at the COMMAND state, the system returns to RUN
and continues.

     Any word which appears in the SHOW or TELL trees can be
abbreviated by typing its first two letters.  For example,
our first command above could have been abbreviated as:
SH FU MEET
Note that arguments cannot be abbreviated since the system has no
list to check the abbreviations against.  This is also true
of responses to a "SPECIFY" REQUEST.  Responses to a "CHOOSE" REQUEST
are abbreviated by typing any initial letter string followed by
<period> as described above.

ยง anno/winograd/lisp

======================================================================
              LISP FUNCTIONS AND WHERE THEY WERE CALLED
======================================================================

*DIF
           CALLED BY USER FUNCTIONS-
                                 THVAL-MULT DP

-
           CALLED BY USER FUNCTIONS-
                                 TIME-SINCE

=
           CALLED BY USER FUNCTIONS-
                                 GROW

ADD1
           CALLED BY USER FUNCTIONS-
                                 FINDNUM THVAL-MULT NAMENUM LISTNAMES
                                 ANSELIMINATE SMNG3 PLNR-FINDSPEC
                                 MAKESYM CLEANX SHRDLU

AND
           CALLED BY USER FUNCTIONS-
                                 INITIALSTUFF DEFINE QUERY SUBLEAF
                                 SHOWSCENE ***TOPLEVEL*** PEV
                                 UNLABELTRACE PASSING LABELTRACE
                                 STARTHISTORY PACKORD PACKO OCCUPIER
                                 MEMOREND FINDSPACE CLEAR VBFIX2
                                 VBFIX NAMEVENT MUNG FINDCHOOSE
                                 THVAL-MULT PREPPUT ONECHECK
                                 NAMESUGAR NAMEOBJ LISTNAMES HEADPART
                                 FINDMOTHER DESCRIBEVENT ANSWER
                                 ANSREL ANSQUEST ANSNOREL ANSGEN
                                 ANSELIMINATE SMBIND SMCL-MODIFIERS
                                 SMCL1 SMRELATE SMPOSS2 SMPOSS SMONE3
                                 SMONE2 SMONE SMNG3 SMNG2 SMIT2 SMIT
                                 SMADJG-PREPG SMVG THVAL2 EXPAND
                                 RELFIND PLNR-DESCRIBE PLNR-REMTIME
                                 PLNR-RECOMMENDIFY MAPBLAND BUILD
                                 IMPERF? ISTENSE CANPARSE BOTH :
                                 UPCHECK UPREL SECONDWORD? POP PARSE3
                                 PARSE2 ONLY-ONE-WORD-LEFT FOLLOWING
                                 FLUSHME MOVE-PTW MOVE-PT
                                 ONE-WORD-LEFT REMOVE-F-PT ADD-F-PT
                                 DEFS WALLP PR2 ETNEW ERTEX DISP
                                 COMBINATION? CLEANX BUILDWORDLIST
                                 BUILDWORD DP ETAOIN TIMER SHRDLU DA

APPEND
           CALLED BY USER FUNCTIONS-
                                 VBFIX PRTPUT NAMEVENT FINDCHOOSE
                                 NAMEOBJ LISTNAMES FINDMOTHER ELIZA
                                 DESCRIBEVENT ANSREL ANSQUEST
                                 ANSNOREL ANSNAME ANSCOMMAND
                                 NAMEACTION SMNG3 SMPRON SETQQCHECK
                                 ORDMAKE PLNR-PROGIFY PLNR-GOALIFY
                                 PLNR-FINDIFY MAPBLAND CANPARSE
                                 CANTAKE PARSE3 PARSE2 MAKESYM ETAOIN

APPLY
           CALLED BY USER FUNCTIONS-
                                 SHOWMOVE SHOWPROP SHOWTELLCHOICE
                                 SHOWTELL ***TOPLEVEL*** MEMOREND
                                 NAMESIZE FINDMOTHER ELIZA ANSQUEST
                                 ANSDECLARE MEASURE CANPARSE
                                 INTERPRET DSAY SHRDLU

ASCII
           CALLED BY USER FUNCTIONS-
                                 REQUEST QUERY ***TOPLEVEL***

ASSOC
           CALLED BY USER FUNCTIONS-
                                 SHOWSCENE NAMEOBJ LISTNAMES
                                 FINDMEASURE

ASSQ
           CALLED BY USER FUNCTIONS-
                                 ATAB ELIZA SMCL1

ATOM
           CALLED BY USER FUNCTIONS-
                                 UNLABELTRACE PASSING LABELTRACE SIZE
                                 LISTIFY FINDCHOOSE ANSTHMELEMENT
                                 ANSTHM CHECKREL WHO EXPAND
                                 PLNR-REMTIME PLNR-JUNKIFY2
                                 PLNR-JUNKIFY MAPBLAND EVALCHECK
                                 ATOMIFY GOCHECK UPREL PARSE3
                                 MOVE-PTW MOVE-PT PR2 PR1 ERTEX NTH
                                 LIS2FY

CAAAR
           CALLED BY USER FUNCTIONS-
                                 PACKORD

CAADDR
           CALLED BY USER FUNCTIONS-
                                 PACKON GROW FINDSPACE PLNR-MUNG

CAADR
           CALLED BY USER FUNCTIONS-
                                 GROW FINDSPACE LISTNAMES MOVE-PTW
                                 MOVE-PT

CAAR
           CALLED BY USER FUNCTIONS-
                                 TFIND STARTIME ORDER OCCUPIER
                                 MEMOREND GROW FINDSPACE ENDTIME
                                 CLEAR MUNG PARSE-ASSOC ANSELIMINATE
                                 PARSEREL PARSE3

CADAAR
           CALLED BY USER FUNCTIONS-
                                 PACKORD

CADADR
           CALLED BY USER FUNCTIONS-
                                 GROW FINDSPACE NAMEACTION

CADAR
           CALLED BY USER FUNCTIONS-
                                 SHOWSCENE STARTHISTORY OCCUPIER GROW
                                 FINDSPACE CLEAR

CADDAR
           CALLED BY USER FUNCTIONS-
                                 OCCUPIER CLEAR NAMEOBJ ANSELIMINATE

CADDDR
           CALLED BY USER FUNCTIONS-
                                 IASS NAMEACTION PLNR-MUNG
                                 BUILDWORDLIST
CADDR
           CALLED BY USER FUNCTIONS-
                                 ***TOPLEVEL*** UNLABELTRACE
                                 LABELTRACE TCENT SUPPORT SIZE PACKON
                                 OCCUPIER LOCGREATER GROW FINDSPACE
                                 CLEAR PARAP MUNG NAMEACTION QTYPE?
                                 PLNR-MUNG PLNR-JUNKIFY2 PLNR-JUNKIFY
                                 BUILDWORDLIST BCWL ETAOIN

CADR
           CALLED BY USER FUNCTIONS-
                                 DEFINETHEOREM ONOFF ***TOPLEVEL***
                                 CHARG SHOWSCENE TCENT SUPPORT
                                 STARTHISTORY PACKORD PACKON PACKO
                                 OCCUPIER LOCGREATER GROW FINDSPACE
                                 CLEAR VBFIX2 PARAP NAMEVENT MUNG
                                 IASS FINDNUM FINDCHOOSE LISTNAMES
                                 ANSWER ANSREL ANSORDER ANSNOREL
                                 ANSNAME ANSELIMINATE SMCL1 SMONE3
                                 QUANTIFIER? SETQQCHECK EXPAND
                                 MEASURE FINDMEASURE PLNR-PROGIFY
                                 PLNR-NOTIFY PLNR-MUNG PLNR-FINDSPEC
                                 PLNR-FINDIFY PLNR-THCONSIFY
                                 PLNR-JUNKIFY2 PLNR-JUNKIFY MUMBLE
                                 MAPC2 NEWCOPY BUILD GOCOND GOCHECK
                                 SECONDWORD? PARSE3 ISQ MOVE-PTW
                                 MOVE-PT DEFS MOD DISP DEFLIST
                                 BUILDWORDLIST BCWL DP ETAOIN

CAR
           CALLED BY USER FUNCTIONS-
                                 DEFINE ***TOPLEVEL*** SHOWPROP QUERY
                                 SHOWTELL SHOWCHOICE TELLCHOICE
                                 SHOWSCENE UNLABELTRACE LABELTRACE
                                 TCENT SUPPORT STARTHISTORY PACKORD
                                 PACKON ORDER OCCUPIER MEMOREND GROW
                                 GOAL FINDSPACE CLEAR VBFIX2 PARAP
                                 NAMEVENT FINDNUM FINDCHOOSE
                                 PLURALMAKE PLURALIZE ONECHECK
                                 NAMEOBJ LISTNAMES ELIZA DESCRIBEVENT
                                 ANSWER ANSTHM ANSREL ANSORDER
                                 ANSNOREL ANSNAME PARSE-ASSOC
                                 ANSELIMINATE ANSCOMMAND NAMEACTION
                                 SMBIND SMCL1 SMONE3 SMONE SMNG3
                                 SMNG2 SMIT2 SMIT SMVG NUMBER?
                                 CHECKAMARKER CHECK WHO SETQQCHECK
                                 EXPAND PLNR-DESCRIBE
                                 PLNR-RECOMMENDIFY PLNR-PROGIFY
                                 PLNR-NOTIFY PLNR-MUNG PLNR-GOALIFY
                                 PLNR-FINDSPEC PLNR-FINDIFY
                                 PLNR-THCONSIFY PLNR-JUNKIFY2
                                 PLNR-JUNKIFY MUMBLE MAPC2 MAPBLAND
                                 ITERATEX EVALCHECK DOBACKREF NEWCOPY
                                 BUILD IMPERF? ISTENSE ATOMIFY BOTH
                                 GOCOND PDEFINE WORD SETR ROOT PTFIND
                                 PREVIOUS POP PARSE3 PARSE2 PARSE NQ
                                 NEXTWORD? NEXTWORD NEXTW GETR CQ
                                 MOVE-PTW MOVE-PT REMOVE-F-PT
                                 ADD-F-PT DEFS UNION STA SETDIF MOD
                                 MEET ETNEW ERTEX DISP DEFLIST
                                 BUILDWORDLIST BCWL PROPNAME DP
                                 ETAOIN NTH LIS2FY

CATCH
           CALLED BY USER FUNCTIONS-
                                 INITIALSTUFF SUBLEAF SHRDLU

CDAAR
           CALLED BY USER FUNCTIONS-
                                 ANSNAME

CDADR
           CALLED BY USER FUNCTIONS-
                                 MOVE-PTW MOVE-PT

CDAR
           CALLED BY USER FUNCTIONS-
                                 MUNG

CDDDDR
           CALLED BY USER FUNCTIONS-
                                 MUNG PLNR-MUNG

CDDDR
           CALLED BY USER FUNCTIONS-
                                 MUNG : BUILDWORDLIST ETAOIN

CDDR
           CALLED BY USER FUNCTIONS-
                                 ***TOPLEVEL*** UNLABELTRACE
                                 LABELTRACE LOCG2 SETQQCHECK
                                 PLNR-PROGIFY PLNR-FINDIFY
                                 PLNR-THCONSIFY MAPC2 NEWCOPY :
                                 ONE-WORD-LEFT DEFS DP ETAOIN

CDR
           CALLED BY USER FUNCTIONS-
                                 DEFINETHEOREM ***TOPLEVEL*** CHARG
                                 SHOWPROP QUERY UNLABELTRACE
                                 LABELTRACE TFIND PACKORD PACKON
                                 ORDER OCCUPIER GROW ENDTIME CLEAR
                                 PRTPUT PARAP NAMEVENT FINDREDUCE
                                 FINDCHOOSE PLURALIZE ONECHECK
                                 NAMEOBJ LISTNAMES FINDMOTHER ELIZA
                                 DESCRIBEVENT CUTOFF ANSWER ANSREL
                                 ANSORDER PARSE-ASSOC ANSELIMINATE
                                 SMBIND SMONE3 SMONE2 SMONE SMNG3
                                 SMNG1 SMIT SMCONJ2 CHECKAMARKER
                                 CHECK SETQQCHECK EXPAND
                                 PLNR-DESCRIBE COMPARE-BUILD
                                 PLNR-PROGIFY PLNR-MUNG PLNR-FINDIFY
                                 MAPBLAND ITERATEX DOBACKREF NEWCOPY
                                 IMPERF? ISTENSE ATOMIFY : PDEFINE
                                 UPREL SECONDWORD? PREVIOUS POPTO POP
                                 PARSEREL PARSE3 ONLY-ONE-WORD-LEFT
                                 FOLLOWING FLUSHME CUT MOVE-PTW
                                 MOVE-PT ONE-WORD-LEFT DEFS UNION STA
                                 SETDIF PRINTC MEET FROM FINDB ETNEW
                                 DISP DEFLIST COMBINATION? BCWL DP
                                 ETAOIN NTH

COND
           CALLED BY USER FUNCTIONS-
                                 INITIALSTUFF SW HELP DEFINE
                                 DEFINETHEOREM ONOFF CHARG SHOWPROP
                                 REQUEST QUERY SUBL2 SHOWTELL
                                 SHOWSCENE ***TOPLEVEL***
                                 UNLABELTRACE PASSING LABELTRACE
                                 TIMECHK TFIND SUPPORT SIZE PACKORD
                                 PACKON ORDER OCCUPIER LOCG2 LISTIFY
                                 GROW FINDSPACE ENDTIME CLEAR ABSVAL
                                 VBFIX PRTPUT PARAP NAMEVENT MUNG
                                 IASS FINDREDUCE FINDNUM FINDCHOOSE
                                 TOPLEVEL THVAL-MULT PLURALIZE
                                 PREPPUT PLNR-ANDORIFY ORDNAME
                                 ONECHECK NAMESUGAR NAMESIZE NAMEOBJ
                                 LISTNAMES FINDMOTHER ELIZA
                                 DESCRIBEVENT ANSWER ANSTHMELEMENT
                                 ANSTHMADD ANSTHM ANSREL ANSQUEST
                                 ANSORDER ANSNOREL ANSGEN PARSE-ASSOC
                                 ANSELIMINATE ANSDECLARE ANSCOMMAND
                                 AMBPUT NAMEACTION SMBIND
                                 SMCL-MODIFIERS SMCL1 SMONE3 SMONE2
                                 SMONE SMNG3 SMNG1 SMIT2 SMIT
                                 SMADJG-PREPG SMVAUX SMPRON SMVG
                                 CHECKREL CHECKAMARKER CHECK WHO
                                 THVAL2 SETQQCHECK ERQSET EXPAND
                                 COMPARE-PROC RELFIND PLNR-DESCRIBE
                                 FINDMEASURE COMPARE-BUILD
                                 PLNR-REMTIME PLNR-NUMSUB PLNR-NUMREL
                                 PLNR-PROGIFY PLNR-NOTIFY PLNR-MUNG
                                 PLNR-GOALIFY PLNR-FINDSPEC
                                 PLNR-FINDIFY PLNR-THCONSIFY
                                 PLNR-JUNKIFY2 PLNR-JUNKIFY MUMBLE
                                 MAPC2 MAPBLAND ITERATEX EVALCHECK
                                 DOBACKREF NEWCOPY ISTENSE ATOMIFY
                                 CANPARSE CANTAKE BOTH COMMA CONJ
                                 GOCOND GOCHECK : INTERPRET PTFIND
                                 PREVIOUS POPTO POP PARSEREL PARSE3
                                 PARSE2 PARSE F CUT APPLY-GRAMMAR
                                 MOVE-PTW MOVE-PT SPACE TAB DEFS
                                 UNION STA SETDIF PRINTC PRINTEXT
                                 PRINT2 PR1 MEET MAKESYM FROM FINDB
                                 ERTEX DISP DP DTABLE ETAOIN
                                 INTEROGATE SHRDLU NTH LIS2FY

CONS
           CALLED BY USER FUNCTIONS-
                                 ***TOPLEVEL*** SHOWPROP QUERY
                                 LABELTRACE PACKORD ORDER MEMORY
                                 LOCG2 GROW PRTPUT PARAP MUNG
                                 PLURALIZE PREPPUT ONECHECK NAMESUGAR
                                 NAMEOBJ LISTNAMES DESCRIBEVENT
                                 ANSTHMADD ANSREL ANSELIMINATE
                                 ANSDECLARE ANSAY SAYIFY PRON-PRT
                                 NAMEACTION SMNG3 SMNG2 SMIT2 SMCONJ2
                                 CHECKAMARKER SETQQCHECK EXPAND
                                 PLNR-DESCRIBE PLNR-PROGIFY
                                 PLNR-NEWBODY PLNR-MUNG MAPBLAND
                                 ITERATEX POP PARSE3 MQ M FQ F
                                 MOVE-PT ADD-F-PT UNION SETDIF PR2
                                 MEET FROM ERTEX BUG COMBINATION?
                                 BCWL ETAOIN

CURSORPOS
           CALLED BY USER FUNCTIONS-
                                 INITIALSTUFF

DEFPROP
           CALLED BY USER FUNCTIONS-
                                 STARTHISTORY

DELETE
           CALLED BY USER FUNCTIONS-
                                 ANSDECLARE

DELQ
           CALLED BY USER FUNCTIONS-
                                 LISTNAMES PLNR-REMTIME

DIFFERENCE
           CALLED BY USER FUNCTIONS-
                                 GROW FINDSPACE DIFF FINDCHOOSE
                                 ANSNOREL ANSCOMMAND TAB

DO
           CALLED BY USER FUNCTIONS-
                                 CLEANX
EQ
           CALLED BY USER FUNCTIONS-
                                 INITIALSTUFF SW HELP DEFINE ONOFF
                                 REQUEST QUERY SUBL2 ***TOPLEVEL***
                                 PEV SUPPORT SIZE PACKORD LOCG2
                                 FINDSPACE VBFIX PARAP NAMEVENT MUNG
                                 IASS FINDNUM FINDCHOOSE TOPLEVEL
                                 ONECHECK NAMEOBJ FINDMOTHER ELIZA
                                 DESCRIBEVENT ANSTHMELEMENT ANSREL
                                 ANSNOREL PARSE-ASSOC ANSCOMMAND
                                 NAMEACTION SMONE3 SMNG3 SMIT2 WHO
                                 THVAL2 SETQQCHECK EXPAND
                                 PLNR-DESCRIBE PLNR-NUMSUB
                                 PLNR-PROGIFY PLNR-NOTIFY PLNR-MUNG
                                 PLNR-FINDSPEC PLNR-FINDIFY
                                 PLNR-THCONSIFY PLNR-JUNKIFY2
                                 PLNR-JUNKIFY MUMBLE EVALCHECK
                                 NEWCOPY IMPERF? ISTENSE CANTAKE
                                 INTERPRET SECONDWORD? PTFIND
                                 PREVIOUS POPTO POP PARSE3 PARSE2
                                 NEXTWORD? NEXTW FLUSHME CUT MOVE-PTW
                                 MOVE-PT REMOVE-F-PT ADD-F-PT DP STA
                                 PRINTC FROM FINDB ETNEW ERTEX
                                 PROPNAME ETAOIN INTEROGATE

EQUAL
           CALLED BY USER FUNCTIONS-
                                 REQUEST THVAL-MULT ORDNAME ONECHECK
                                 NAMESUGAR ANSGEN ANSELIMINATE SMCL1
                                 SMVG ISTENSE CANPARSE CANTAKE CLEANX
                                 ETAOIN NTH

ERR
           CALLED BY USER FUNCTIONS-
                                 REQUEST QUERY GROW ANSGEN RELFIND
                                 POP

ERRSET
           CALLED BY USER FUNCTIONS-
                                 SW STARTHISTORY GROW ANSGEN RELFIND
                                 POP ERTEX ETAOIN SHRDLU
EVAL
           CALLED BY USER FUNCTIONS-
                                 INITIALSTUFF SW LOCG2 GROW NAMEVENT
                                 SAYIFY NAMELIST-EVALED SMBIND
                                 SMCL-MODIFIERS SMCL1 SMONE2 SMNG1
                                 SMADJG-PREPG SMADJ SMPRON SETQQCHECK
                                 EXPAND PLNR-RECOMMENDIFY PLNR-NUMSUB
                                 ITERATEX ITERATE EVALCHECK BUILD :
                                 PTFIND POPTO POP PARSEREL PARSE3
                                 PARSE2 ISQ APPLY-GRAMMAR MOVE-PTW
                                 MOVE-PT CALLSM PRINTC PRINTEXT ERTEX
                                 DISP COMBINATION? INTEROGATE
                                 PARSEVAL

EXPLODE
           CALLED BY USER FUNCTIONS-
                                 QUERY ABBREVIATE VBFIX PLURALMAKE
                                 ORDNAME NAMEOBJ CUTOFF MAKESYM
                                 COMBINATION? BCWL PROPNAME

FLATSIZE
           CALLED BY USER FUNCTIONS-
                                 PRINT3 PRINT2

FUNCTION
           CALLED BY USER FUNCTIONS-
                                 PACKO GROW PARAP NAMEVENT IASS SMNG2
                                 SMNGOF SMIT2 SMIT PLNR-NUMSUB PARSE3
                                 FQ PR2 DEFLIST CLEANOUT ETAOIN

GENSYM
           CALLED BY USER FUNCTIONS-
                                 ITERATEX

GET
           CALLED BY USER FUNCTIONS-
                                 DEBUGMODE TREEPRINT SUBL2 SUBLEAF
                                 SHOWTELL ***TOPLEVEL*** PEV
                                 UNLABELTRACE LABELTRACE TIMECHK
                                 TFIND STARTHISTORY VBFIX PARAP
                                 NAMEVENT FINDCHOOSE TOPLEVEL
                                 PLURALMAKE ONECHECK NAMEOBJ
                                 DESCRIBEVENT ANSTHM NAMEACTION
                                 SMBIND SMCL-MODIFIERS SMONE3 SMONE
                                 SMIT VARIABLE? TSS? TENSE? SYSTEMS?
                                 START? RSSVAR? RSS? RELMARKERS?
                                 RELATIONS? REL? REFER? QUANTIFIER?
                                 QTYPE? PLNRCODE? PLAUSIBILITY?
                                 PARSENODE? OSS? OR? NUMBER?
                                 NEGATIVE? MODIFIERS? MARKERS? END?
                                 DETERMINER? ANSRSS? AND?
                                 AMBIGUITIES? ACTION? CHECKAMARKER
                                 WHO PLNR-DESCRIBE FINDMEASURE
                                 PLNR-RECOMMENDIFY PLNR-GOALIFY
                                 MUMBLE DOBACKREF INTERPRET ROOT
                                 PARSE3 PARSE2 GETR APPLY-GRAMMAR
                                 REMOVE-F-PT PR2 MAKESYM ERTEX DISP
                                 CLEANX CLEANUP CLEANOUT DTABLE
                                 ETAOIN DA

GO
           CALLED BY USER FUNCTIONS-
                                 INITIALSTUFF SW DEFINE REQUEST QUERY
                                 UNLABELTRACE LABELTRACE TFIND PACKON
                                 OCCUPIER GROW FINDSPACE ENDTIME
                                 CLEAR FINDREDUCE FINDCHOOSE ONECHECK
                                 LISTNAMES ANSWER ANSORDER
                                 PARSE-ASSOC ANSELIMINATE SMCL1
                                 SMONE3 SMONE2 SMONE SMNG3 SMNG1 SMIT
                                 CHECKAMARKER CHECK SETQQCHECK
                                 PLNR-DESCRIBE MAPC2 MAPBLAND NEWCOPY
                                 GOCOND GOCHECK INTERPRET PTFIND
                                 PREVIOUS POPTO PARSEREL PARSE3
                                 PARSE2 CUT MOVE-PTW MOVE-PT SPACE
                                 TAB DEFS UNION STA SETDIF PRINTC
                                 MEET ERTEX DP ETAOIN INTEROGATE
                                 SHRDLU NTH

GREATERP
           CALLED BY USER FUNCTIONS-
                                 TFIND PACKORD PACKON ORDER GROW
                                 ENDTIME CLEAR FINDCHOOSE PLURALIZE
                                 NAMESIZE ENOUGH-BETTER ANSREL
                                 ANSELIMINATE SMNG3 MUMBLE SPACE TAB
                                 PRINT3 PRINT2 CLEANX

INTERN
           CALLED BY USER FUNCTIONS-
                                 MAKESYM COMBINATION? BCWL

LAST
           CALLED BY USER FUNCTIONS-
                                 ETNEW ETAOIN

LENGTH
           CALLED BY USER FUNCTIONS-
                                 FINDCHOOSE ELIZA ANSREL ANSELIMINATE
                                 SMNG3 BOTH

LESSP
           CALLED BY USER FUNCTIONS-
                                 TIMECHK STARTIME OCCUPIER LOCGREATER
                                 GROW FINDSPACE CLEAR ELIZA ANSREL
                                 ANSORDER SMNG3 WHO MUMBLE BOTH NTH

LIST
           CALLED BY USER FUNCTIONS-
                                 DEFINE DEFINETHEOREM SHOWTELLCHOICE
                                 SHOWTELL SHOWSCENE ***TOPLEVEL***
                                 LABELTRACE TCENT STARTHISTORY
                                 PACKORD PACKO ORDER MEMOREND LISTIFY
                                 GROW GOAL FINDSPACE VBFIX2 PRTPUT
                                 NAMEVENT MUNG FINDNUM FINDCHOOSE
                                 THVAL-MULT NAMESUGAR NAMELIST
                                 NAMEOBJ LISTNAMES ELIZA ANSTHMADD
                                 ANSTHM ANSREL ANSNOREL ANSELIMINATE
                                 ANSDECLARE ANSCOMMAND ANSAY PRON-PRT
                                 NAMELIST-EVALED SMPOSS2 SMONE SMNG3
                                 SMNG1 SMPROP SMNEWPROPN FINDEVENTS
                                 CHECK SETQQCHECK EXPAND COMPARE-PROC
                                 ORDMAKE MEASURE COMPARE-BUILD
                                 PLNR-VAR PLNR-NOTIFY PLNR-MUNG
                                 PLNR-GOALIFY PLNR-FINDSPEC
                                 PLNR-FINDIFY PLNR-THCONSIFY
                                 PLNR-JUNKIFY2 PLNR-JUNKIFY ITERATEX
                                 CANPARSE CANTAKE PDEFINE BUILDNODE
                                 REMOVE-F-PT WALLP PR2 PR1
                                 COMBINATION? BCWL DTABLE ETAOIN
                                 LIS2FY QUOTIFY

LISTIFY
      THIS FUNCTION WAS A SYSTEM FUNCTION TILL YOU REDEFINED IT
           CALLED BY USER FUNCTIONS-
                                 DEFINE DEFINETHEOREM SHOWMOVE
                                 SHOWPROP GROW FINDSPACE CLEAR
                                 NAMEVENT

MAKNAM
           CALLED BY USER FUNCTIONS-
                                 PLURALMAKE MAKESYM COMBINATION? BCWL

MAP
           CALLED BY USER FUNCTIONS-
                                 UNLABELTRACE LABELTRACE SMCL2 SMCL1
                                 SMIT RELFIND DOBACKREF POP

MAPC
           CALLED BY USER FUNCTIONS-
                                 SW NOPAUSES QUIETMODE TREEPRINT
                                 QUERY SUBL2 SUBLEAF SHOWSCENE
                                 ***TOPLEVEL*** PEV UNLABELTRACE
                                 LABELTRACE STARTHISTORY PACKO GROW
                                 NAMEVENT IASS ANSELIMINATE SMIT
                                 PLNR-PROGIFY DOBACKREF BUILD SAY PR2
                                 ERTEX DEFLIST COMBINATION? CLEANUP
                                 CLEANOUT BUILDWORDLIST BCWL % DTABLE
                                 ETAOIN INTEROGATE

MAPCAN
           CALLED BY USER FUNCTIONS-
                                 DESCRIBEVENT ANSQUEST ANSDECLARE
                                 CHECKREL PLNR-JUNKIFY2 PLNR-JUNKIFY

MAPCAR
           CALLED BY USER FUNCTIONS-
                                 QUERY ABBREVIATE PACKO DIFF CLEAR
                                 PLNR-ANDORIFY LISTNAMES DESCRIBEVENT
                                 ANSWER ANSTHM ANSQUEST ANSDECLARE
                                 SAYIFY SMRELATE SMIT2 SMADJG-PREPG
                                 SMCONJ2 EXPAND PLNR-REMTIME
                                 PLNR-NUMSUB PLNR-JUNKIFY2
                                 PLNR-JUNKIFY FQ

MAPLIST
           CALLED BY USER FUNCTIONS-
                                 FINDMOTHER ELIZA PR1

MAX
           CALLED BY USER FUNCTIONS-
                                 FINDSPACE

MEMBER
           CALLED BY USER FUNCTIONS-
                                 REQUEST QUERY ANSELIMINATE SMVG
                                 PLNR-REMTIME ISTENSE ISX F ERTEX

MEMQ
           CALLED BY USER FUNCTIONS-
                                 ***TOPLEVEL*** PASSING GROW
                                 FINDSPACE CLEAR VBFIX2 PARAP IASS
                                 PLURALIZE NAMESUGAR NAMEOBJ ANSREL
                                 SMRELATE SMNG3 SMIT2 CHECKREL
                                 CHECKAMARKER SETQQCHECK EXPAND
                                 MEASURE PLNR-NUMSUB PLNR-NUMREL
                                 PLNR-FINDSPEC CANPARSE CANTAKE BOTH
                                 UPREL PARSE3 PARSE2 PARSE NQ ISQ FQ
                                 FOLLOWING FEATURE? CQ UNION SETDIF
                                 PR2 MEET ERTEX DP ETAOIN

MIN
           CALLED BY USER FUNCTIONS-
                                 GROW FINDSPACE

MINUS
           CALLED BY USER FUNCTIONS-
                                 ABSVAL TIMER

MINUSP
           CALLED BY USER FUNCTIONS-
                                 OCCUPIER GROW ABSVAL

NCONC
           CALLED BY USER FUNCTIONS-
                                 DEFINE DEFINETHEOREM PLURALMAKE
                                 ORDNAME NAMEOBJ SMIT2 PLNR-FINDIFY
                                 PLNR-THCONSIFY MAPBLAND ITERATEX
                                 PDEFINE COMBINATION? BCWL

NOT
           CALLED BY USER FUNCTIONS-
                                 INITIALSTUFF QUERY UNLABELTRACE
                                 TIMECHK TFIND LOCGREATER GROW
                                 FINDSPACE ENDTIME ONECHECK NAMEOBJ
                                 ELIZA DISPUT ANSWER ANSTHMELEMENT
                                 ANSTHM ANSQUEST ANSNOREL
                                 ANSELIMINATE ANSDECLARE SMCL1 SMONE3
                                 SMNG3 SMNG2 SMIT2 SMIT WHO EXPAND
                                 RELFIND PLNR-REMTIME PLNR-NOTIFY
                                 MUMBLE BUILD CANTAKE UPCHECK UPREL
                                 PTFIND POP PARSEREL PARSE3 PARSE2
                                 ONLY-ONE-WORD-LEFT FLUSHME CUT
                                 MOVE-PTW MOVE-PT ONE-WORD-LEFT TAB
                                 FROM ERTEX ETAOIN SHRDLU

NULL
           CALLED BY USER FUNCTIONS-
                                 ***TOPLEVEL*** SHOWPROP SHOWTELL
                                 PACKORD PACKON ORDER OCCUPIER GROW
                                 ENDTIME CLEAR PARAP ONECHECK NAMEOBJ
                                 LISTNAMES DESCRIBEVENT ANSREL
                                 ANSORDER ANSNOREL PARSE-ASSOC
                                 SMCL-MODIFIERS SMONE3 SMONE2 SMNG3
                                 SMNG1 SMIT SMPRON CHECKAMARKER CHECK
                                 WHO SETQQCHECK EXPAND PLNR-DESCRIBE
                                 MUMBLE MAPC2 MAPBLAND ITERATEX
                                 NEWCOPY CANPARSE CANTAKE GOCHECK :
                                 PREVIOUS POP PARSEREL PARSE3 PARSE2
                                 CUT MOVE-PTW MOVE-PT DEFS UNION STA
                                 SETDIF PRINTC MEET FINDB ETAOIN

NUMBERP
           CALLED BY USER FUNCTIONS-
                                 NAMEVENT FINDNUM NAMESIZE ANSREL
                                 ANSELIMINATE SMNG3 PLNR-FINDSPEC
                                 ETAOIN

OR
           CALLED BY USER FUNCTIONS-
                                 INITIALSTUFF DEBUGMODE DEFINE
                                 SHOWMOVE ***TOPLEVEL*** REQUEST
                                 QUERY TIMECHK TFIND STARTIME PACKORD
                                 PACKON MEMORY MEMOREND GROW
                                 FINDSPACE EV ENDTIME ATAB VBFIX
                                 PARAP NAMEVENT IASS FINDCHOOSE
                                 THVAL-MULT PLURALMAKE ONECHECK
                                 NAMESIZE NAMENUM NAMEOBJ DISPUT
                                 DESCRIBEVENT ANSTHM ANSREL ANSQUEST
                                 ANSNAME ANSGEN ANSELIMINATE SMBIND
                                 SMCL-MODIFIERS SMCL1 SMRELATE SMONE3
                                 SMONE2 SMONE SMNG3 SMNG1 SMIT
                                 SMADJG-PREPG SMVAUX SMCONJ2
                                 PLAUSIBILITY? EXPAND RELFIND
                                 PLNR-PROGIFY PLNR-JUNKIFY2
                                 PLNR-JUNKIFY OBJECT MUMBLE ITERATEX
                                 DOBACKREF BUILD ISTENSE CANPARSE
                                 INTERPRET UPREL ROOT PTFIND POP
                                 PARSE3 PARSE2 FQ MOVE-PT CALLSM
                                 PRINT3 PR2 MAKESYM FROM ERTEX CLEANX
                                 BUILDWORD ETAOIN SHRDLU

PLUS
           CALLED BY USER FUNCTIONS-
                                 TREEPRINT PEV TCENT SUPPORT PACKON
                                 OCCUPIER LOCGREATER GROW FINDSPACE
                                 CLEAR NAMESIZE ENOUGH-BETTER ANSREL
                                 ANSQUEST ANSNOREL ANSDECLARE ERTEX

PRINC
           CALLED BY USER FUNCTIONS-
                                 INITIALSTUFF SW TREEPRINT QUERY
                                 SHOWSCENE PEV UNLABELTRACE PASSING
                                 LABELTRACE IASS ANSWER ANSELIMINATE
                                 SPACE TAB UNDEFINED PRINTC PRINT3
                                 PRINT2 ERTEX DISP % DP DTABLE ETAOIN
                                 TIMER

PRINT
           CALLED BY USER FUNCTIONS-
                                 DEFINETHEOREM QUERY SHOWSCENE
                                 UNLABELTRACE PASSING LABELTRACE
                                 ANSWER ANSELIMINATE SETQQCHECK
                                 DOBACKREF PARSE2 MOVE-PT ERTEX
                                 BUILDWORDLIST DTABLE ETAOIN TIMER
                                 SHRDLU

PROG
           CALLED BY USER FUNCTIONS-
                                 INITIALSTUFF SW SWITCHES DEFINE
                                 ***TOPLEVEL*** SHOWPROP REQUEST
                                 QUERY SHOWSCENE UNLABELTRACE
                                 LABELTRACE TFIND PACKON PACKO
                                 OCCUPIER GROW FINDSPACE ENDTIME
                                 CLEAR PARAP NAMEVENT IASS FINDREDUCE
                                 FINDCHOOSE THVAL-MULT PLURALMAKE
                                 ONECHECK NAMESUGAR NAMEOBJ LISTNAMES
                                 ELIZA DESCRIBEVENT ANSWER ANSTHM
                                 ANSREL ANSQUEST ANSORDER ANSNOREL
                                 ANSNAME ANSGEN PARSE-ASSOC
                                 ANSELIMINATE ANSDECLARE ANSCOMMAND
                                 NAMELIST-EVALED NAMEACTION SMBIND
                                 SMCL1 SMRELATE SMPOSS2 SMPOSS SMONE3
                                 SMONE2 SMONE SMNG3 SMNG1 SMIT
                                 SMADJG-PREPG SMVG SMCONJ2 SMCONJ
                                 CHECKAMARKER CHECK THVAL2 SETQQCHECK
                                 EXPAND COMPARE-PROC ORDMAKE RELFIND
                                 PLNR-DESCRIBE COMPARE-BUILD
                                 PLNR-RECOMMENDIFY PLNR-PROGIFY
                                 PLNR-THCONSIFY OBJECT MAPC2 MAPBLAND
                                 ITERATE DOBACKREF NEWCOPY BUILD
                                 ISTENSE CANPARSE CANTAKE BOTH CONJ
                                 INTERPRET PTFIND PREVIOUS POPTO POP
                                 PARSEREL PARSE3 PARSE2 CUT BUILDNODE
                                 MOVE-PTW MOVE-PT SETMVB SPACE TAB
                                 DEFS WALLP UNION STA SETDIF PRINTC
                                 MEET ERTEX COMBINATION? CLEANX DP
                                 ETAOIN INTEROGATE SHRDLU NTH

PROG2
           CALLED BY USER FUNCTIONS-
                                 UNDEFINED PRINT3

PUTPROP
           CALLED BY USER FUNCTIONS-
                                 DEFINE ***TOPLEVEL*** DEFINETHEOREM
                                 ABBREVIATE UNLABELTRACE LABELTRACE
                                 STARTHISTORY MEMORY MEMOREND
                                 FINDCHOOSE DISPUT ANSREL ANSNOREL
                                 ANSNAME ANSCOMMAND SMBINDER SMPOSS2
                                 SMNG3 SMIT SMVAUX SMVG FINDEVENTS
                                 EXPAND COMPARE-BUILD PLNR-THCONSIFY
                                 VALUEPUT DOBACKREF NEWCOPY BUILD
                                 PDEFINE SETR REMOVE-F-PT ADD-F-PT
                                 DEFS MAKESYM DEFLIST CLEANX CLEANUP
                                 CLEANOUT BUILDWORD

QUOTE
           CALLED BY USER FUNCTIONS-
                                 INITIALSTUFF SW DEBUGMODE NOPAUSES
                                 QUIETMODE HELP DEFINE DEFINETHEOREM
                                 ONOFF SHOWMOVE SHOW TREEPRINT TELL
                                 SHOWPROP REQUEST QUERY SHOWTELL
                                 SHOWSCENE ABBREVIATE PEV
                                 UNLABELTRACE PASSING LABELTRACE
                                 TIMECHK TFIND SUPPORT STARTHISTORY
                                 SIZE PACKO OCCUPIER MEMORY MEMOREND
                                 LOCG2 LOCGREATER GROW GOAL FINDSPACE
                                 CLEAR VBFIX PARAP NAMEVENT MUNG
                                 FINDNUM FINDCHOOSE TOPLEVEL
                                 THVAL-MULT PLURALMAKE PLURALIZE
                                 PREPPUT ORDNAME ONECHECK NAMESUGAR
                                 NAMESIZE NAMENUM NAMELIST NAMEOBJ
                                 LISTNAMES FINDMOTHER ELIZA DISPUT
                                 DESCRIBEVENT ANSWER ANSTHMELEMENT
                                 ANSTHM ANSREL ANSQUEST ANSNOREL
                                 ANSNAME ANSGEN ANSELIMINATE
                                 ANSDECLARE ANSCOMMAND ANSAY SAYIFY
                                 PRON-PRT NAMELIST-EVALED NAMEACTION
                                 SMBINDER SMBIND SMCL-MODIFIERS SMCL1
                                 SMRELATE SMPOSS2 SMONE3 SMONE SMNG3
                                 SMNG2 SMNG1 SMIT2 SMIT SMADJG-PREPG
                                 SMVAUX SMPRON SMVG SMCONJ2
                                 SMNEWPROPN SMSET VARIABLE? TSS?
                                 TENSE? SYSTEMS? START? RSSVAR? RSS?
                                 RELMARKERS? RELATIONS? REL? REFER?
                                 QUANTIFIER? QTYPE? PLNRCODE?
                                 PLAUSIBILITY? PARSENODE? PARENT?
                                 OSS? OR? NUMBER? NEGATIVE?
                                 MODIFIERS? MARKERS? END? DETERMINER?
                                 ANSRSS? AND? AMBIGUITIES? ACTION?
                                 CHECKREL FINDEVENTS CHECKAMARKER WHO
                                 THVAL2 SETQQCHECK EXPAND
                                 COMPARE-PROC ORDMAKE RELFIND
                                 PLNR-DESCRIBE MEASURE FINDMEASURE
                                 COMPARE-BUILD PLNR-VAR PLNR-REMTIME
                                 PLNR-RECOMMENDIFY PLNR-NUMSUB
                                 PLNR-PROGIFY PLNR-NOTIFY PLNR-MUNG
                                 PLNR-GOALIFY PLNR-FINDSPEC
                                 PLNR-FINDIFY PLNR-THCONSIFY VALUEPUT
                                 PLNR-JUNKIFY2 PLNR-JUNKIFY OBJECT
                                 MUMBLE MAPBLAND ITERATEX EVALCHECK
                                 DOBACKREF NEWCOPY BUILD IMPERF
                                 IMPERF? ISTENSE CANPARSE CANTAKE
                                 DOUBLEQUOTER BOTH COMMA CONJ
                                 INTERPRET PDEFINE UPCHECK UPREL
                                 TRNSF SM RQ ROOT REBUILD POP PARSE3
                                 PARSE2 PARSE PARENT NB N H FQ FESET
                                 FE F BUILDNODE APPLY-GRAMMAR
                                 MOVE-PTW MOVE-PT REMOVE-F-PT
                                 ADD-F-PT SETMVB SPACE TAB PRINTC
                                 PRINT3 PRINT2 PR2 PR1 MAKESYM ETNEW
                                 ERTEX BUG DISP COMBINATION? CLEANX
                                 CLEANUP CLEANOUT BUILDWORDLIST
                                 BUILDWORD BCWL PROPNAME DP DTABLE
                                 ETAOIN INTEROGATE TIMER SHRDLU
                                 ***TOPLEVEL*** DA QUOTIFY

QUOTIENT
           CALLED BY USER FUNCTIONS-
                                 DIV2 TIME-SINCE

RANDOM
           CALLED BY USER FUNCTIONS-
                                 FINDSPACE

READ
           CALLED BY USER FUNCTIONS-
                                 INITIALSTUFF REQUEST ANSELIMINATE
                                 ERTEX

READCH
           CALLED BY USER FUNCTIONS-
                                 SW REQUEST QUERY ERTEX ETAOIN
                                 INTEROGATE

READLIST
           CALLED BY USER FUNCTIONS-
                                 ABBREVIATE VBFIX ORDNAME NAMEOBJ
                                 CUTOFF CANTAKE ETNEW ETAOIN

REMAINDER
           CALLED BY USER FUNCTIONS-
                                 FINDSPACE

REMOB
           CALLED BY USER FUNCTIONS-
                                 CLEANX

REMPROP
           CALLED BY USER FUNCTIONS-
                                 SMIT DOBACKREF

RETURN
           CALLED BY USER FUNCTIONS-
                                 SW DEFINE REQUEST QUERY TFIND PACKON
                                 PACKO OCCUPIER GROW FINDSPACE
                                 ENDTIME CLEAR PARAP NAMEVENT IASS
                                 FINDREDUCE FINDCHOOSE THVAL-MULT
                                 PLURALMAKE ONECHECK NAMESUGAR
                                 NAMEOBJ LISTNAMES ELIZA DESCRIBEVENT
                                 ANSWER ANSTHM ANSREL ANSQUEST
                                 ANSORDER ANSNOREL ANSNAME ANSGEN
                                 PARSE-ASSOC ANSELIMINATE ANSDECLARE
                                 ANSCOMMAND NAMELIST-EVALED
                                 NAMEACTION SMBIND SMCL1 SMRELATE
                                 SMPOSS2 SMPOSS SMONE3 SMONE2 SMONE
                                 SMNG3 SMNG1 SMIT SMADJG-PREPG SMVG
                                 SMCONJ2 SMCONJ CHECKAMARKER CHECK
                                 THVAL2 SETQQCHECK EXPAND
                                 COMPARE-PROC ORDMAKE RELFIND
                                 PLNR-DESCRIBE COMPARE-BUILD
                                 PLNR-RECOMMENDIFY PLNR-PROGIFY
                                 PLNR-THCONSIFY OBJECT MAPC2 MAPBLAND
                                 ITERATE NEWCOPY BUILD ISTENSE
                                 CANPARSE CANTAKE BOTH CONJ INTERPRET
                                 PTFIND PREVIOUS POPTO PARSEREL
                                 PARSE3 PARSE2 CUT BUILDNODE MOVE-PTW
                                 MOVE-PT SETMVB TAB DEFS UNION STA
                                 SETDIF PRINTC MEET ERTEX
                                 COMBINATION? CLEANX DP ETAOIN
                                 INTEROGATE NTH

REVERSE
           CALLED BY USER FUNCTIONS-
                                 ***TOPLEVEL*** PEV GOAL VBFIX
                                 FINDCHOOSE ONECHECK ANSCOMMAND
                                 SMONE3 RELFIND PLNR-PROGIFY
                                 INTERPRET WALLP UNION SETDIF PR1
                                 MEET ETNEW ERTEX ETAOIN

RPLACA
           CALLED BY USER FUNCTIONS-
                                 GROW ANSORDER

RPLACD
           CALLED BY USER FUNCTIONS-
                                 UNLABELTRACE LABELTRACE MUNG

RUNTIME
           CALLED BY USER FUNCTIONS-
                                 ERTEX TIME-SINCE SHRDLU

SASSOC
           CALLED BY USER FUNCTIONS-
                                 PARSE3

SASSQ
           CALLED BY USER FUNCTIONS-
                                 IASS
SET
           CALLED BY USER FUNCTIONS-
                                 NOPAUSES QUIETMODE GROW NAMEVENT
                                 SETQQCHECK

SETQ
           CALLED BY USER FUNCTIONS-
                                 INITIALSTUFF SW SWITCHES DEBUGMODE
                                 USERMODE NORMALFEATUREMODE DEFINE
                                 DEFINETHEOREM SHOWMOVE REQUEST QUERY
                                 SHOWCHOICE TELLCHOICE SHOWSCENE
                                 ***TOPLEVEL*** UNLABELTRACE PASSING
                                 LABELTRACE LBK TFIND SUPPORT
                                 STARTHISTORY PACKON PACKO OCCUPIER
                                 GROW GOAL FINDSPACE ENDTIME CLEAR
                                 VBFIX PARAP NAMEVENT MUNG IASS
                                 FINDREDUCE FINDCHOOSE THVAL-MULT
                                 PLURALMAKE PREPPUT ONECHECK
                                 NAMESUGAR NAMESIZE NAMEOBJ LISTNAMES
                                 HEADPART ELIZA DESCRIBEVENT ANSWER
                                 ANSTHMELEMENT ANSTHMADD ANSTHM
                                 ANSREL ANSQUEST ANSORDER ANSNOREL
                                 ANSNAME ANSGEN PARSE-ASSOC
                                 ANSELIMINATE ANSDECLARE ANSCOMMAND
                                 NAMELIST-EVALED NAMEACTION SMBIND
                                 SMCL1 SMRELATE SMPOSS2 SMPOSS SMONE3
                                 SMONE2 SMONE SMNG3 SMNG2 SMNG1 SMIT2
                                 SMADJG-PREPG SMPRON SMVG SMCONJ2
                                 SMSET CHECKAMARKER CHECK WHO THVAL2
                                 SETQQCHECK ERQSET EXPAND ORDMAKE
                                 RELFIND PLNR-DESCRIBE FINDMEASURE
                                 PLNR-RECOMMENDIFY PLNR-NUMREL
                                 PLNR-PROGIFY PLNR-NEWBODY
                                 PLNR-GOALIFY PLNR-FINDIFY
                                 PLNR-THCONSIFY OBJECT MUMBLE MAPC2
                                 MAPBLAND ITERATEX DOBACKREF NEWCOPY
                                 BUILD IMPERF? ISTENSE CANPARSE
                                 CANTAKE BOTH CONJ INTERPRET TRNSF RQ
                                 PTFIND PREVIOUS POPTO POP PARSEREL
                                 PARSE3 PARSE2 MQ MP M FQ FLUSHME F
                                 CUT BUILDNODE MOVE-PTW MOVE-PT
                                 REMOVE-F-PT ADD-F-PT SETMVB
                                 RESTOREPT SPACE TAB DEFS WALLP UNION
                                 STA SETDIF PRINTC PR2 MEET MAKESYM
                                 ETNEW ERTEX GLOBAL-ERR COMBINATION?
                                 CLEANX DP ETAOIN INTEROGATE SHRDLU
                                 NTH

SSTATUS
           CALLED BY USER FUNCTIONS-
                                 ***TOPLEVEL***

STATUS
           CALLED BY USER FUNCTIONS-
                                 WALLP DISP

SUB1
           CALLED BY USER FUNCTIONS-
                                 SUPPORT OCCUPIER FINDSPACE
                                 FINDREDUCE SMNG3 SPACE ETAOIN NTH

SUBLIS
           CALLED BY USER FUNCTIONS-
                                 PARAP

SUBST
           CALLED BY USER FUNCTIONS-
                                 FINDCHOOSE PLURALMAKE PLURALIZE
                                 EXPAND ORDMAKE PLNR-DESCRIBE

TERPRI
           CALLED BY USER FUNCTIONS-
                                 INITIALSTUFF SW TREEPRINT SHOWSCENE
                                 PEV ANSWER ANSELIMINATE WALLP PRINTC
                                 PRINTEXT PRINT3 PRINT2 ERTEX DISP %
                                 DP ETAOIN INTEROGATE

THROW
           CALLED BY USER FUNCTIONS-
                                 SUBL2 ERTEX

TRACE
           CALLED BY USER FUNCTIONS-
                                 ***TOPLEVEL***

TYI
           CALLED BY USER FUNCTIONS-
                                 ETAOIN

TYIPEEK
           CALLED BY USER FUNCTIONS-
                                 REQUEST ERTEX ETAOIN

TYO
           CALLED BY USER FUNCTIONS-
                                 QUERY WALLP DISP ETAOIN

UREAD
           CALLED BY USER FUNCTIONS-
                                 INITIALSTUFF HELP

ZEROP
           CALLED BY USER FUNCTIONS-
                                 FINDSPACE FINDREDUCE NAMESUGAR
                                 ANSREL ETAOIN

(*DIF - = ADD1 AND APPEND APPLY ASCII ASSOC ASSQ ATOM CAAAR CAADDR CAA
DR CAAR CADAAR CADADR CADAR CADDAR CADDDR CADDR CADR CAR CATCH CDAAR C
DADR CDAR CDDDDR CDDDR CDDR CDR COND CONS CURSORPOS DEFPROP DELETE DEL
Q DIFFERENCE DO EQ EQUAL ERR ERRSET EVAL EXPLODE FLATSIZE FUNCTION GEN
SYM GET GO GREATERP INTERN LAST LENGTH LESSP LIST LISTIFY MAKNAM MAP M
APC MAPCAN MAPCAR MAPLIST MAX MEMBER MEMQ MIN MINUS MINUSP NCONC NOT N
ULL NUMBERP OR PLUS PRINC PRINT PROG PROG2 PUTPROP QUOTE QUOTIENT RAND
OM READ READCH READLIST REMAINDER REMOB REMPROP RETURN REVERSE RPLACA
RPLACD RUNTIME SASSOC SASSQ SET SETQ SSTATUS STATUS SUB1 SUBLIS SUBST
TERPRI THROW TRACE TYI TYIPEEK TYO UREAD ZEROP)

ยง anno/winograd/mannew

     On the A.I. machine, a reasonably fluent
and debuged version of SHRDLU is alway availlable as
SHRDLU > DSK SHRDLU and can be run as a job
by typing SHRDLU<cntrl. k> at DDT. This version is
in interpreted with
all its options including a grind and trace. Consequently
it occupies arround 200k of core (caution: indiscriminately
running a job that big in the middle of the day is a

good way to make enemies!!!!! Alway check the level
of system usage befoere loading.
.sp 1
     The first sign of life from SHRDLU looks
like this:
          SHRDLU version 101   created on 4-27-73
           type <space> to go to "ready" state, type "?" for help
          >>>
.sp 1
     The version number has certain accessable
information associated with it describing the actual
files used in this version and any phenomena peculiar to it.
the prompt characters ">>>" are produced by the system's
handcrafted real-eval-print loop. When this has
been printed you are boht talking to LISP where you can do any
of the normal things (check values of bound variables, evaluate functions.
etc.) and you can use the SHOW-TELL mechanism which is designed
as a convenient way to fiddle with SHRDLU's knobs & switches,
define new wiords, examine sturctures as they are set up, etc.
More about it later.
     SHRDLU is dumped with all its display options turned
off so that the initial command state is a reasionable place to
set the parameters the way you want them before running any
sentences. All the options will be described in the next
section.
.sp 1
     Moving from this state to the one where
SHRDLU accepts sentences is doen by typing
"t " (the letter "t" followed by a space). The responce
will be:
          READY <cr>
     At this point you can type in a sentence and
it will be interpreted and responded to. Mistyped
letters within a word can bve erased
by typing a <rubout> in the usua; manner and unintended
words can be removed by typing a <rubout> agter an
intervening break character (comma or space usualy). As soon
as the sentence terminating punctuation (. ? !) has been
typed, the sentence is automaticly processed and unless
some display options have been turned on, (or you stumbled across a bug !!)
the next thing that you see will be the
responce to what you typed in from SHRDLU.A switch can be set (see the next section)
to cause a break at this point (immediately
after a response) and
permit the examination of the various structures that were added to the program's
memory for example. Without the break (or after it has been dismissed
we get another "READY" and can continue as before.
     The break-loop (otherwise known as "command state")
can be entered fron the "ready state" by typing <altmode><altmode>
instead of stsrting a sentence. Exiting from it will result
in another "READY".

ยง anno/winograd/manual

                             PROVISIONAL

                        SHRDLU USERS' MANUAL

                             (Version 0)

                   S. Card, A. Rubin, T. Winograd

                          For CMU-1 Version
                            10/50 Monitor

                           August 14, 1972
                     Carnegie-Mellon University
                        Pittsburgh, Pa 15213

BRIEF DESCRIPTION OF SHRDLU
---------------------------

         SHRDLU IS A SYSTEM FOR THE  COMPUTER  UNDERSTANDING
    OF  ENGLISH.    THE  SYSTEM  ANSWERS QUESTIONS, EXECUTES
    COMMANDS, AND  ACCEPTS  INFORMATION  IN  NORMAL  ENGLISH
    DIALOG.    IT  USES  SEMANTIC INFORMATION AND CONTEXT TO
    UNDERSTAND DISCOURSE AND TO DISAMBIGUATE SENTENCES.   IT
    COMBINES  A COMPLETE SYNTACTIC ANALYSIS OF EACH SENTENCE
    WITH A "HEURISTIC  UNDERSTANDER"  WHICH  USES  DIFFERENT
    KINDS  OF  INFORMATION  ABOUT A SENTENCE, OTHER PARTS OF
    THE DISCOURSE, AND GENERAL INFORMATION ABOUT  THE  WORLD
    IN DECIDING WHAT THE SENTENCE MEANS.

         SHRDLU  IS  BASED  ON  THE  BELIEF  THAT A COMPUTER
    CANNOT DEAL  REASONABLY  WITH  LANGUAGE  UNLESS  IT  CAN
    "UNDERSTAND"  THE  SUBJECT IT IS DISCUSSING. THE PROGRAM
    IS GIVEN A DETAILED MODEL OF THE KNOWLEDGE NEEDED  BY  A
    SIMPLE  ROBOT  HAVING  ONLY A HAND AND AN EYE.  THE USER
    CAN GIVE IT  INSTRUCTIONS  TO  MANIPULATE  TOY  OBJECTS,
    INTERROGATE  IT ABOUT THE SCENE, AND GIVE IT INFORMATION
    IT WILL USE IN DEDUCTION.  IN ADDITION  TO  KNOWING  THE
    PROPERTIES  OF  TOY  OBJECTS,  THE  PROGRAM HAS A SIMPLE
    MODEL OF  ITS  OWN  MENTALITY.    IT  CAN  REMEMBER  AND
    DISCUSS ITS PLANS AND ACTIONS AS WELL AS CARRY THEM OUT.
    IT ENTERS INTO A DIALOG WITH  A  PERSON,  RESPONDING  TO
    ENGLISH  SENTENCES WITH ACTIONS AND ENGLISH REPLIES, AND
    ASKING FOR CLARIFICATION  WHEN  ITS  HEURISTIC  PROGRAMS
    CANNOT  UNDERSTAND A SENTENCE THROUGH USE OF CONTEXT AND
    PHYSICAL KNOWLEDGE.

         IN THE PROGRAMS, SYNTAX, SEMANTICS,  AND  INFERENCE
    ARE INTEGRATED IN A "VERTICAL" SYSTEM IN WHICH EACH PART
    IS CONSTANTLY COMMUNICATING WITH THE OTHERS. SHRDLU USES
    SYSTEMIC  GRAMMAR, A TYPE OF SYNTACTIC ANALYSIS WHICH IS
    DESIGNED  TO  DEAL  WITH   SEMANTICS.      RATHER   THAN
    CONCENTRATING  ON  THE EXACT FORM OF RULES FOR THE SHAPE
    OF LINGUISTIC  CONSTITUENTS,  IT  IS  STRUCTURED  AROUND
    CHOICES   FOR  CONVEYING  MEANING.    IT  ABSTRACTS  THE
    RELEVANT FEATURES OF THE LINGUISTIC STRUCTURES WHICH ARE
    IMPORTANT FOR INTERPRETING THEIR MEANING.

         IN  SHRDLU  MANY KINDS OF KNOWLEDGE ARE REPRESENTED
    IN THE FORM OF PROCEDURES RATHER THAN TABLES OF RULES OR
    LISTS  OF  PATTERNS.    BY DEVELOPING SPECIAL PROCEDURAL
    LANGUAGES FOR GRAMMAR, SEMANTICS, AND  DEDUCTIVE  LOGIC,
    THE  FLEXIBILITY  AND  POWER OF PROGRAMMING LANGUAGES IS
    GAINED    WHILE    RETAINING    THE    REGULARITY    AND
    UNDERSTANDABILITY  OF SIMPLER RULE FORMS.  EACH PIECE OF
    KNOWLEDGE CAN BE A PROCEDURE, AND CAN CALL ON ANY  OTHER
    PIECE OF KNOWLEDGE IN THE SYSTEM.

IMPLEMENTATION AND VERSION INFORMATION
--------------------------------------

    SHRDLU  WAS  PROGRAMMED  AT   THE   MIT   ARTIFICIAL
    INTELLIGENCE  LABORATORY  BY  T.   WINOGRAD AS PART OF A
    DOCTORAL DISSERTATION IN MATHEMATICS.

    THE PROGRAM WAS MODIFIED DURING THE LAST YEAR BY  T.
    WINOGRAD,  D.  MACDONALD, J. HILL, AND S. CARD TO CHANGE
    SOME OF ITS INTERNAL REPRESENTATIONS  AND  TO  MAKE  THE
    CODE  EASIER  TO UNDERSTAND FOR PERSONS WISHING TO STUDY
    THE PROGRAM.  NO MAJOR ATTEMPTS WERE  MADE  TO  INCREASE
    ITS POWER.

    THE PROGRAM RUNNING AT C-MU IS THE MODIFIED VERSION.
    THE DISPLAY FACILITIES OF  THE  PROGRAM  HAVE  NOT  BEEN
    IMPLEMENTED  AT  C-MU.  THE PROGRAM WAS COAXED AWAY FROM
    MIT'S  INCOMPATIBLE  TIME-SHARING   SYSTEM   (ITS)   AND
    CONVERTED  TO RUN UNDER THE DEC TOPS10 (10-50) OPERATING
    SYSTEM BY CONVERTING MACLISP ITSELF  (AND  TO  DO  THAT,
    CONVERTING  THE  MIDAS  ASSEMBLY LANGUAGE).  THE MACLISP
    CONVERSION WAS DONE BY GEORGE ROBERTSON.

THE VERSION OF SHRDLU BEING DISTRIBUTED FROM  CMU  IS  NAMED
    THE  C1  VERSION.  IT IS CURRENT WITH THE MIT VERSION TO
    JUNE 1972.  THE SHOW AND TELL USER INTERFACE AND VARIOUS
    CHANGES   WERE  ADDED  FOR  THE  C-MU  WORKSHOP  ON  NEW
    TECHNOLOGIES IN COGNITIVE RESEARCH IN JUNE 1972.

    SHRDLU IS  WRITTEN  IN  MACLISP  1.6  (VINTAGE  JUNE
    1972).  IT USES ABOUT 100 TO 140K 36-BIT WORDS OF MEMORY
    ON A PDP-10.

THE SHRDLU DISTRIBUTION PACKAGE
-------------------------------

    A  distribution  package  of  the C1 system has been
    make up containing basically

    1. a SAV copy of MACLSP which runs under a version
    of the DEC 10/50 monitor on a PDP-10. TRACE and GRIND
    files are also included.

    2.  a MICROPLANNER (EXPR version)

    3.  a SHRDLU, in two parts.

Together  these constitute a SHRDLU Kit from which it should
    be possible to fashion a full SHRDLU  or  a  parser-only
    system  or  a  MICROPLANNER.   It  is  thought  that the
    package has a good chance of running on any (unmodified)
    10/50  system  or  on  any  other  system  with  a fully
    compatible MACLISP (ha!).

The system currently running at C-mu uses 134K of core,  but
    with  hand  editing this should go down to 100k.  Please
    note that a SAVE file of the system occupies between 800
    and  1000  blocks  of  disk  space.  A SAVE file is not,
    therefor, even remotely close to fitting onto a DECTAPE.

MACLISP:
    MACLISP  has  not been completely implemented.  This
    version is, however, sufficient to run SHRDLU.  A couple
    perversities:

    1. most LISP control characters don't work.  To
    do a <control g> type (IOC G).

    2. Because of an incompatibility problem, UWRITE files
    and (IOC B) printer output are double spaced.

    3. occasionally the garbage collector fails.
    (IOC D) makes it print out every time it is garbage-
    collecting so you can usually figure out what
    happened.  (IOC C) turns off this printout.  To
    get around the garbage collector's always failing
    in the same place in your program, try forcing
    a garbage collect with (GC) so that it gets to
    garbage collect in some other part of your program.

It is possible to obtain a version of MICROPLANNER which has
    been  compliled  into  LAP  in which case you need a LAP
    loader (which comes in both LAP and EXPR versions).  The
    LISP  compiler does work in 10-50 MACLISP so if you want
    to roll your own that is available too.   All of this is
    another good couple of DECTAPES.

SHRDLU is distributed as 2 large files to prevent parts from
    falling off and for ease  in  loading.   The  boundaries
    between  the  traditional  SHRDLU files used for editing
    are indicate by (e.g.)  ;;;[S->GLOBAL]  which  indicates
    the  Start  of a subfile called GLOBAL.  TECO buffs take
    note.

CAVEAT EMPTOR
-------------

This  set  of  probrams  is  distributed  in  the  cause  of
    dissemination of research.  There is no warranty  either
    expressed  or  implied  for  labor, parts, or servicing.
    Various bugs are known to lurk in  the  systems:  SHRDLU
    bugs  +  MICROPLANNER bugs + MACLISP bugs + MIDAS bugs +
    conversion  bugs   +   Monitor   bugs   +   installation
    incompatability  bugs  +  hardware bugs. Furthermore the
    system is presently in a state  of  development  (active
    and  suspended)  with various uncompleted projects here,
    notes to friends there, etc.

ASSEMBLING YOUR SHRDLU KIT
--------------------------

Before you begin assembling a SHRDLU it is probably wise  to
    get a listing of all of files (except MACLSP!!!).  Start
    by listing this one.  It is also helpful to transfer all
    of  the  files  to  dsk.  The names are designed so that
    this  can  be  done  with  pip  in   few   instructions.
    BEWARE!!!!  when  moving MACLSP around with PIP remember
    to use the /B switch.

Also note that the alt-mode which MACLSP looks for  to  tell
    it  that  you are through doing allocation is an 033 and
    not a 175 or 176.  The MACLISP editor also  requires  an
    033.   If  you  don't  have one type <space> after every
    allocation opportunity when entering MACLSP.  And  don't
    type (EDIT) or you'll get stuck.

Below  is  the  TTY listing for building a SHRDLU.  What you
    type is indicated in lower case letters, what  it  types
    in capitals.

..........STEP 1: Reading in and allocating MACLSP

.run dsk:maclsp

BIG NUMBER LISP 229
ALLOC? y
CORE = 26       170
FXS = 2000      $

*

..........STEP 2: Reading in MICROPLANNER

(uread plnr c1)
(DSK +)
(ioc q)
T

COMMENT

C1

DECLARE

    .
    .
    .
   etc

..........STEP 3: Reading in Trace and GRIND files

(uread trace c1)
(DSK +)
(ioc q)
T

TRACE 16, LOADING:
(? ?? REMTRACE UNTRACE TRACE)
FOR EXPLANATION, TYPE
(?)
(uread grind c1)
(DSK +)
(ioc q)
T
LOADING GRIND C1
*
(uread grinit c1)
(DSK +)
(ioc q)
T

BUILD

(ERT ERTSTOP ERTERR GLOBAL-ERR BUG SAY)

PDEFINE

DEFS

(OBJECT RELATION)

(thinit)

((PRINT (QUOTE MICRO-PLANNER)) (PRINC THVERSION) (COND ((ERRSET (APPLY
 (QUOTE UREAD) (APPEND (QUOTE (/.PLNR/. /(INIT/))) (CRUNIT))) NIL) (SE
TQ ERRLIST (CDDDDR ERRLIST)) (SETQ THTREE NIL) (SETQ THLEVEL NIL) (THE
RT TH%0% READING /.PLNR/. /(INIT/)))) (SETQ ERRLIST (CDDDDR ERRLIST))
(SETQ THINF NIL) (SETQ THTREE NIL) (SETQ THLEVEL NIL) (THERT TOP LEVEL
))

..........STEP3-1/2: Arming MICROPLANNER - This MUST be done to activate Macro-characters for subsequent readins

(ioc q)QUIT
MICRO-PLANNER C1
>>>  TOP-LEVEL
LISTENING  THVAL

..........STEP 3-3/4: (OPTIONAL) This is a good place to do a SAVE to hedge against subsequent disaster.

^C
.sav dsk:shrdlu
JOB SAVED

.start

>>>  TOP LEVEL
LISTENING  THVAL

..........STEP 4: Reading first SHRDLU file

(uread shrdl1 c1)
DSK ")
(ioc q)
T

ERT

ERTEX

PRINT2

   .
   .
   .
  ETC

..........STEP 5: Reading 2nd SHRDLU file

(uread shrdl2 c1)
(DSK ")
(ioc q)
T
ABSVAL

   .
   .
   .
  etc

..........STEP 6: Arming SHRDLU

(ioc g)
(ioc g)QUIT

..........STEP 7: INITIAL switch settings. Don't you dare.

      At this point SHRDLU will print out a list of some
      its internal switches and invite you to change them.
      The first time you run the program you should probably
      leave them as they are (type space after each arrow).
      Within SHRDLU these same switches can be changed
      with the TELL command.  Or, if you insist, this same
      display can be brought back by evaluating (SW).

      Then SHRDLU will print
READY

..........STEP 8: Saving SHRDLU

      Save immediately before you mung up the nice clean
      core image inside by playing with it.

^C
.sav dsk:shrdlu
JOB SAVED

..........STEP 9: Playing with SHRDLU.

.start

READY
      Now SHRDLU wants to eat a sentence.  And please don't
      forget the proper punctuation, especially the terminal
      punctuation mark at the end. Type sentences in
      upper case.  A capitalization is indicated by (e.g.) =A.
      This is useful for getting proper nouns across to
      the program.  The beginning of a sentence need not be capitalized.

      See Appendices 2 through 6 for examples
 To see if program is running try
      doing

<control x>
LISTENING---> tell parsing node on
*
LISTENING---> <CONTROL X>
READY
PICK UP A BIG RED BLOCK.

      The parser should start happily spewing forth
      trace messages.

INSTRUCTIONS FOR RUNNING SHRDLU
-------------------------------

     SHRDLU can be in 4 basic states, COMMAND, READY, RUN,
and REQUEST.  It is initially in COMMAND when loaded.

***
******COMMAND STATE
***

     In this state, SHRDLU expects the user to type a command.
It lets you know this by typing "LISTENING-->".
A command is a line containing one or more words, separated by
spaces and terminated by a carriage return (<CR>).  The first
word must be one of the three words SHOW, TELL, or GO.  The
SHOW command is used to ask the system to show such things
as definitions, structures it is building, and the states of various
parameters and switches.  TELL is used to tell the system new
definitions and settings.
     After executing a COMMAND, the system is ready for
another one, and prompts by saying LISTENING-->.
You can leave COMMAND state by typing <CONTROL X>
instead of a command.  This will cause the program to continue
whatever it was doing before it entered COMMAND
state, or to go to READY state if it was not already in the
process of analyzing a sentence.  If instead, you type the
command "GO", it will drop the sentence it is working on, and go
into READY state for a new one.

****
******COMMAND FORMATS
****

     The SHOW and TELL commands are based on a ZOG-like tree
(one tree for each).  The first word of the command is SHOW
or TELL, the second names a node in the corresponding tree,
and the rest are any arguments appropriate to the action
at that node.
For example, the command:

SHOW FUNCTION MEET

will display the contents of the LISP function "MEET".

SHOW SHOW

displays the "SHOW" tree, while for the "TELL" tree, you type

SHOW TELL

     If all of the arguments are not specified, the system will
request more.  For example, typing:
SHOW FUNCTION
would cause it to type out:
FUNCTION:
requesting the name of a function from the user.  It is then
in REQUEST state (see below.)
     Non-terminal nodes of the tree may or may not have corresponding
actions.  For example, the command

TELL PLANNER OFF

causes the entire batch of PLANNER tracing devices to be turned off
at once, even though there are subnodes of the PLANNER node which
can be used to turn individual features on and off selectively.
If there is no action associated with such a node, the system will
ask the user to select one of its subnodes.
     If you type "SHOW" or "HELP" followed by a carriage return,
it will guide you through the choices, using REQUESTS
(see below).

*****
*****REQUEST STATE
*****

     SHRDLU can request two kinds of information from
the user.  If it wants him to CHOOSE between a set of alternatives,
it will end the request with a ?.  If it wants him to SPECIFY
a name or list of names, it will end it with a :.
     For a CHOOSE, all it needs is enough information to decide
between the alternatives.  Begin typing your choice, and when it
is complete enough, type a <control x>.  If you type fewer
letters than necessary (e.g. typing just a P, when PLANNER
and PARSING are among the choices) it will ring the bell and wait
for you to continue.  If you type more than necessary it doesn't
matter.
     For a SPECIFY, type the required response, terminated by a
<CR>.  If you type a <CR> with nothing else, it will take some
default response which is appropriate to the action (For example,
typing a <CR> in response to a request for which properties of an
atomare to be displayed will have the effect of displaying
all of them.
    For either SPECIFY or CHOOSE, you can get more information on
what is expected by typing a ?<CR>.  It will then give you the
request again.  Typing QUIT<CR> at a "SPECIFY" REQUEST or QUIT
<CONTROL X> at a "CHOOSE" REQUEST will cause the entire command
of which it was a part to be discarded without finishing,
returning to COMMAND state.

*****
******READY STATE
*****

     The READY state is entered only when a new English sentence is to
be input.  You can tell you are in it when the sytem types
READY
Respond by typing in an English sentence in normal punctuation
(i.e. ending with a question mark or period) followed by a <CR>.
The system will automatically begin processing it, entering
RUN state.  To get into a COMMAND state while entering a sentence,
type a <CONTROL X>.

*****
******RUN STATE
*****

     Whenever a sentence is input, the system begins to RUN.  It
will stop at selected places, entering COMMAND state so the user can
SHOW things and TELL it things before continuing.  There are various
TELL commands which explain how to change these stopping points.
When a <CONTROL X> is typed at the COMMAND, the system returns to RUN
and continues.

*****
*******ABBREVIATIONS
*****

     Any word which appears in the SHOW or TELL trees can be
abbreviated by typing its first two letters.  For example,
our first command above could have been abbreviated as:
SH FU MEET
Note that arguments cannot be abbreviated since the system has no
list to check the abbreviations against.  This is also true
of responses to a "SPECIFY" REQUEST.  Responses to a "CHOOSE" REQUEST
are abbreviated by typing any initial letter string followed by
<CONTROL X> as described above.

To  see examples of the various commands, run one of the demonstration
programs.  They inclde explanatory comments.

SOME FACTS ABOUT THE PROGRAM
----------------------------

1. PARSER
    SHRDLU calls the parser by calling

    (PARSE <CONSTITUENT-CLASS> LIST-OF-SEMANTIC-FEATURES)

    This causes the 'PROGRAMMAR' program which embodies
the grammar for that constituent-class to be run.  Turning
on the parser trace causes a message 'PASSING ...' to
print out as each node in the grammar for the
constituent-class is passed (with a flowchart or program
listing of the grammar you can follow the parsing path
through it).

    At various points the grammar calls on 'Semantic
Specialists' with the

    (CALLSM <SEMANTIC-SPECIALIST>)

function.  If this function returns NIL, the Semantic-Specialist
objected to the parse.

    As the parser progresses it builds and rebuilds a
parser-tree whose nodes are labeled NODE1, NODE2, ... etc.
When the parse-trace is turned on, these nodes are displayed
whenever they are created or changed.

    The parse-tree is really a complex data structure to
which the syntactic and semantic routines contribute
information as it is developed.

    An important concept is that the surface structure of
the sentence is never destroyed.  The parse-node itself
contains pointers to the beginning (FIRSTWORD) and end
(WORDAFTER) of the constituent in the surface structure.
Whenever the grammar finds it has been partially fooled
and must try another parsing it adjusts these pointers.

2. SEMANTIC-SPECIALISTS

    Part of the work of the Semantic Specialists is to build up
interpretive semantic structures as the parsing of the sentence
proceeds.  The semantic structures built include OSS'S (Object
Semantic Structures), RSS'S (Relational Semantic Structures, TSS's
(Time Semantic Structures) and ANS's (Answer Semantic Structures).
    The Semantic Specialists are all entered through the function

    (CALLSM <SEMANTIC-SPECIALIST>)

from the gramar.

3. INFERENCE MECHANISM - PLANNER

    SHRDLU makes all references to its world model
through the function

    (THVAL2 <MICROPLANNER-STATEMENT>).

REFERENCES FOR MORE INFORMATION
-------------------------------

MACLISP
    1. MIT AI Memo 116A PDP-6 LISP (LISP 1.6)
    2. MIT AI Memo 190 - Interim LISP Users' Guide
    3. LISP INFO update file

The first 2 can only be obtained from the MIT AI Laboratory.
The last is available for this version of MACLISP from me (S.C.) at CMU) as well.
These documents contain what you have to know to really use
MACLISP as a programming system (provided you already know
how to use LISP before you read them).  They are probably not
necessary to run SHRDLU (until you get into trouble).

MICROPLANNER
    1. Winograd's thesis is the best introduction to it.
    2. A manual is available from MIT AI Laboratory.
    3. Ira Goldstein (MIT AI Laboratory) has an excellent
        demonstration program for teaching it.
    4. For the real PLANNER stuff there's Hewett's Thesis
       which has been printed and is available from MIT AI Lab.
    5. Hewett also has several AI Memos and papers in the
       two Int'l Conferences on AI.

    6. Sussman and McDermott and there
       friends have recently created a warring siblisng
       to PLANNER called CONNIVER which is explained in
       two AI Memos.

SHRDLU
    1. Winograd's thesis has been published in various
       forms including as issue of
       COGNITIVE PSYCHOLOGY and a book.

    2. You are currently reading what is probably the
       most obscure SHRDLU reference.

APPENDIX 1
----------

      ****** SHRDLU States and What They Want    *****

READY   (types out READY)
     English sentence ended with punctuation, followed by <CR>
        or <CONTROL X> to go to COMMAND
COMMAND  (types out LISTENING--->)
     Command terminated by <CR>
      or <CONTROL X> to proceed program
      or GO<CR> to prepare for new sentence
REQUEST  (types out request)
   CHOOSE (request ends with ?)
     Enough of any choice to specify it, followed by
          <CONTROL X>
        or ?<CONTROL X> to see information and choices
        or QUIT<CONTROL X> to abort command
   SPECIFY   (request ends with :)
     Name or list, ended with <CR>
        or just <CR> for default value (if appropriate)
        or QUIT<CR> to abort command
        or ?<CR> for info
Abbreviate commands by first two letters.

APPENDIX 2:
----------

PARSER TRACES EXAMPLE
======================
(NOTE ^X MEANS <CONTROL-X>)
LISTENING---> SHOW

(SHOW TELL LISP PLANNER PARSING DEFINITIONS INPUT)
WHICH OPTION? SHOW
CANSHOW
       SHOW
       TELL
       LISP
               PROPERTY
               FUNCTION
               VALUE
       PLANNER
               ASSERTIONS
               THEOREM
               SCENE
       PARSING
               NODE
               TREE
       DEFINITIONS
               UNIT
               WORD
               MARKER
       INPUT
               ALL
               REST
               CURRENT
*
LISTENING---> SHOW SCENE
  CURRENT SCENE

:B1 -->  A SMALL RED BLOCK  AT (110 100 0)SUPPORTS (:B2)
:B2 -->  A SMALL GREEN PYRAMID  AT (110 100 100)
:B3 -->  A LARGE GREEN BLOCK  AT (400 0 0)SUPPORTS (:B5)
:B4 -->  A LARGE BLUE PYRAMID  AT (640 640 1)
:B5 -->  A SMALL RED PYRAMID  AT (500 100 200)
:B6 -->  A LARGE RED BLOCK  AT (0 300 0)SUPPORTS (:B7)
:B7 -->  A LARGE GREEN BLOCK  AT (0 240 300)
:B10 -->  A LARGE BLUE BLOCK  AT (300 640 0)
:BOX -->  A LARGE WHITE BOX  AT (600 600 0)SUPPORTS (:B4)
THE HAND IS GRASPING  NOTHING
*
LISTENING---> TELL PARSING

(NODE LABEL ATTEMPT)
WHICH OPTION? NODE
ON OR OFF? ON
LISTENING---> TELL SEMANTICS

DO SEMANTIC ANALYSIS? YES
SHOW BUILDING OF SEMANTIC STRUCTURES? NO
*
LISTENING---> TELL PLANNER OFF

*
LISTENING---> TELL PL

(INPUT ACTION THEOREM ASSERTIONS)
WHICH OPTION? INPUT
ON OR OFF? ON
*
*
LISTENING---> GO
QUIT
READY
PICK UP A BIG RED BLOCK.

[1]

[NODE1]
   SEMANTICS      NIL
   DAUGHTERS      NIL
   WORDAFTER      (PICK UP A BIG RED BLOCK)
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (TOPLEVEL MAJOR CLAUSE)

>>>
LISTENING--->TE AT ON

*
LISTENING---> 
PASSING ENTERING-CLAUSE

[TSS1]
   TSSNODE=       TSS1

>>>
LISTENING---> 
PASSING INIT
PASSING MAJOR
PASSING THEREINIT
PASSING THER2
(1 ENTER PARSE (NG TIME))

[NODE2]
   SEMANTICS      NIL
   DAUGHTERS      NIL
   WORDAFTER      (PICK UP A BIG RED BLOCK)
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (TIME NG)

>>>
LISTENING---> 
PASSING ENTERING-NG
PASSING NGSTART
PASSING TIME
PASSING FAIL
(1 EXIT PARSE NIL)
PASSING CLAUSETYPE
(1 ENTER PARSE (VG IMPER))

[NODE3]
   SEMANTICS      NIL
   DAUGHTERS      NIL

   WORDAFTER      (PICK UP A BIG RED BLOCK)
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (IMPER VG)

>>>
LISTENING---> 
PASSING ENTERING-VG
PASSING IMPER
(2 ENTER PARSE (VB DO NEG INF))
(2 EXIT PARSE NIL)
(2 ENTER PARSE (VB (MVB) INF))

[NODE4]
   SEMANTICS      ((TRANS (#NOTICE)))
   DAUGHTERS      WORD
   WORDAFTER      (UP A BIG RED BLOCK)
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (VPRT VB INF TRANS MVB)

>>>
LISTENING---> 

[NODE3]
   PARENT         (NODE1)
   SEMANTICS      NIL
   DAUGHTERS      (NODE4)
   WORDAFTER      (UP A BIG RED BLOCK)
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (IMPER VG)

>>>
LISTENING---> 
(2 EXIT PARSE (NODE3))
PASSING RETURN

[NODE3]
   PARENT         (NODE1)
   SEMANTICS      NIL
   DAUGHTERS      (NODE4)
   WORDAFTER      (UP A BIG RED BLOCK)
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (VG IMPER)

>>>
LISTENING---> 

[NODE1]
   MVB            (NODE4)
   TIME   TSS1
   PARENT         NIL
   SEMANTICS      NIL
   DAUGHTERS      (NODE3)
   WORDAFTER      (UP A BIG RED BLOCK)
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (TOPLEVEL MAJOR CLAUSE)

>>>
LISTENING---> 
(1 EXIT PARSE (NODE3))
PASSING VG1
(1 ENTER PARSE (PRT))

[NODE5]
   SEMANTICS      T
   DAUGHTERS      WORD
   WORDAFTER      (A BIG RED BLOCK)
   FIRSTWORD      (UP A BIG RED BLOCK)
   FEATURES       (PRT)

>>>
LISTENING---> 

[NODE1]
   MVB            (NODE4)
   TIME   TSS1
   PARENT         NIL
   SEMANTICS      NIL
   DAUGHTERS      (NODE5 NODE3)
   WORDAFTER      (A BIG RED BLOCK)
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (ACTV IMPER TOPLEVEL MAJOR CLAUSE)

>>>
LISTENING---> SHOW TREE

NODE-SPECIFICATION: C
(((PICK UP) (ACTV IMPER TOPLEVEL MAJOR CLAUSE)
             NIL
             (((PICK) (VG IMPER) NIL ((PICK (VPRT VB INF TRANS MVB))))
              (UP (PRT))))
 NIL)
*
LISTENING--->
(1 EXIT PARSE (NODE1))
PASSING TRANSP
(1 ENTER PARSE (NG OBJ OBJ1))

[NODE6]
   SEMANTICS      NIL
   DAUGHTERS      NIL
   WORDAFTER      (A BIG RED BLOCK)
   FIRSTWORD      (A BIG RED BLOCK)
   FEATURES       (OBJ1 OBJ NG)

>>>
LISTENING---> 
PASSING ENTERING-NG
PASSING NGSTART
PASSING LOOK
PASSING DET
(2 ENTER PARSE (DET))

[NODE7]
   SEMANTICS      T
   DAUGHTERS      WORD
   WORDAFTER     (A BIG RED BLOCK)

   FIRSTWORD      (A BIG RED BLOCK)
   FEATURES       (DET NS INDEF)

>>>
LISTENING---> 

[NODE6]
   PARENT         (NODE1)
   SEMANTICS      NIL
   DAUGHTERS      (NODE7)
   WORDAFTER      (BIG RED BLOCK)
   FIRSTWORD      (A BIG RED BLOCK)
   FEATURES       (OBJ1 OBJ NG)

>>>
LISTENING---> 
(2 EXIT PARSE (NODE6))
PASSING IND
PASSING ADJ
(2 ENTER PARSE (ADJ))

[NODE10]
   SEMANTICS      (OBJECT
                      (MARKERS: (#PHYSOB #BIG)
                       PROCEDURE: ((#MORE #SIZE
                                          ***
                                          (200 200
                                               200)))))
   DAUGHTERS      WORD
   WORDAFTER      (RED BLOCK)
   FIRSTWORD      (BIG RED BLOCK)
   FEATURES       (ADJ)

>>>
LISTENING---> 

[NODE6]
   PARENT         (NODE1)
   SEMANTICS      NIL
   DAUGHTERS      (NODE10 NODE7)
   WORDAFTER      (RED BLOCK)
   FIRSTWORD      (A BIG RED BLOCK)
   FEATURES       (INDEF NS DET OBJ1 OBJ NG)

>>>
LISTENING---> 
(2 EXIT PARSE (NODE6))
PASSING ADJ
(2 ENTER PARSE (ADJ))

[NODE11]
   SEMANTICS      (#COLOR #RED)
   DAUGHTERS      WORD
   WORDAFTER      (BLOCK)
   FIRSTWORD      (RED BLOCK)
   FEATURES       (ADJ)

>>>
LISTENING---> 

[NODE6]
   PARENT         (NODE1)
   SEMANTICS      NIL
   DAUGHTERS      (NODE11 NODE10 NODE7)
   WORDAFTER      (BLOCK)
   FIRSTWORD      (A BIG RED BLOCK)
   FEATURES       (INDEF NS DET OBJ1 OBJ NG)

>>>
LISTENING---> SHOW CURRENT

A BIG RED
*
LISTENING---> 
(2 EXIT PARSE (NODE6))
PASSING ADJ
(2 ENTER PARSE (ADJ))
(2 EXIT PARSE NIL)
PASSING CLASF
(2 ENTER PARSE (VB ING (CLASF)))
(2 EXIT PARSE NIL)
(2 ENTER PARSE (VB EN (CLASF)))
(2 EXIT PARSE NIL)
(2 ENTER PARSE (CLASF))
(2 EXIT PARSE NIL)
PASSING NOUN
(2 ENTER PARSE (NOUN))

[NODE12]
   SEMANTICS      (OBJECT
                      (MARKERS: (#MANIP
                                 #RECTANGULAR)
                       PROCEDURE: ((#IS *** #BLOCK))))
   DAUGHTERS      WORD
   WORDAFTER      NIL
   FIRSTWORD      (BLOCK)

   FEATURES       (NOUN NS)

>>>
LISTENING---> 

[NODE6]
   PARENT         (NODE1)
   SEMANTICS      NIL
   DAUGHTERS      (NODE12 NODE11 NODE10 NODE7)
   WORDAFTER      NIL
   FIRSTWORD      (A BIG RED BLOCK)
   FEATURES       (INDEF NS DET OBJ1 OBJ NG)

>>>
LISTENING---> 
(2 EXIT PARSE (NODE6))
PASSING SMNG
(1 ENTER CALLSM ((SMNG1)))

>>>
LISTENING---> 
(1 EXIT CALLSM (OSS4))
PASSING RETSM
(1 ENTER CALLSM ((SMNG2)))
(1 EXIT CALLSM (OSS4))
PASSING RETURN

[NODE6]
   HEAD   (NODE12 NODE11 NODE10 NODE7)
   PARENT         (NODE1)
   SEMANTICS      (OSS4)
   DAUGHTERS      (NODE12 NODE11 NODE10 NODE7)
   WORDAFTER      NIL
   FIRSTWORD      (A BIG RED BLOCK)

   FEATURES       (NG OBJ OBJ1 DET NS INDEF)

>>>
LISTENING---> 

[NODE1]
   MVB            (PICK-UP)
   TIME   TSS1
   PARENT         NIL
   SEMANTICS      NIL
   DAUGHTERS      (NODE6 NODE5 NODE3)
   WORDAFTER      NIL
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (PRT ACTV
                       IMPER
                       TOPLEVEL
                       MAJOR
                       CLAUSE)

>>>
LISTENING---> SHOW WORD PICK-UP

[PICK-UP]
   FEATURES       (COMBINATION TRANS)
   SEMANTICS      ((TRANS
                    (RELATION
                        (RESTRICTIONS: (((#ANIMATE))
                                        ((#MANIP)))
                         MARKERS: (#EVENT)
                         PROCEDURE: ((#EVAL
                                      (COND
                                       ((MEMQ (NUMBER? SMOB1)
                                              '(1 NS))
                                        '(#PICKUP #2 *TIME))
                                       ('(#PUTIN
                                          #2
                                          :BOX
                                          *TIME)))))))))
   ROOT   (PICK UP)

>>>
LISTENING---> 
*
LISTENING---> 
(1 EXIT PARSE (NODE6))
PASSING OBB
PASSING FQPRT
PASSING ONT
(1 ENTER CALLSM ((SMCL1)))

>>>
LISTENING---> 
(1 EXIT CALLSM (RSS1))
PASSING RETSM
(1 ENTER CALLSM ((SMCL2)))
(1 EXIT CALLSM (NODE6 NODE5 NODE3))
PASSING RETURN

[NODE1]
   OBJ1   (NODE6 NODE5 NODE3)
   MVB            (PICK-UP)
   TIME   TSS1
   PARENT         NIL
   SEMANTICS      (RSS1)
   DAUGHTERS      (NODE6 NODE5 NODE3)
   WORDAFTER      NIL
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (CLAUSE MAJOR
                          TOPLEVEL
                          IMPER
                          ACTV
                          PRT
                          TRANS)

>>>
LISTENING---> SHOW TREE C

(((PICK UP A BIG RED BLOCK)
  (CLAUSE MAJOR TOPLEVEL IMPER ACTV PRT TRANS)
  (RSS1)
  (((PICK) (VG IMPER) NIL ((PICK (VPRT VB INF TRANS MVB))))
   (UP (PRT))
   ((A BIG RED BLOCK)
    (NG OBJ OBJ1 DET NS INDEF)
    (OSS4)
    ((A (DET NS INDEF)) (BIG (ADJ)) (RED (ADJ)) (BLOCK (NOUN NS))))))
 NIL)
*
LISTENING---> 

(THAND (THGOAL (#PICKUP OSS4) (THDBF MUMBLE) (THUSE TC-2))
        (VALUEPUT)
        (SETQ SUCCESS T)
        (SETQ PLAN2 PLAN))
>>>  FOR PLANNER
OK.

APPENDIX 3
----------

THIS IS THE SEMANTIC STRUCTURES TRACE FOR "PICK UP A BIG RED BLOCK"
===================================================================
LISTENING---> SHOW

(SHOW TELL LISP PLANNER PARSING DEFINITIONS INPUT)
WHICH OPTION? SHOW
CANSHOW
       SHOW
       TELL
       LISP
               PROPERTY
               FUNCTION
               VALUE
       PLANNER
               ASSERTIONS
               THEOREM
               SCENE
       PARSING
               NODE
               TREE
       DEFINITIONS
               UNIT
               WORD
               MARKER
       INPUT
               ALL
               REST
               CURRENT
*
LISTENING---> SHOW SCENE
  CURRENT SCENE

:B1 -->  A SMALL RED BLOCK  AT (110 100 0)SUPPORTS (:B2)
:B2 -->  A SMALL GREEN PYRAMID  AT (110 100 100)
:B3 -->  A LARGE GREEN BLOCK  AT (400 0 0)SUPPORTS (:B5)
:B4 -->  A LARGE BLUE PYRAMID  AT (640 640 1)
:B5 -->  A SMALL RED PYRAMID  AT (500 100 200)
:B6 -->  A LARGE RED BLOCK  AT (0 300 0)SUPPORTS (:B7)
:B7 -->  A LARGE GREEN BLOCK  AT (0 240 300)
:B10 -->  A LARGE BLUE BLOCK  AT (300 640 0)
:BOX -->  A LARGE WHITE BOX  AT (600 600 0)SUPPORTS (:B4)
THE HAND IS GRASPING  NOTHING
*
LISTENING---> TELL PARSING OFF

*
LISTENING---> TELL SEMANTICS

DO SEMANTIC ANALYSIS? YES
SHOW BUILDING OF SEMANTIC STRUCTURES? YES
*
LISTENING---> TELL PLANNER OFF

*
LISTENING---> TELL PL

(INPUT ACTION THEOREM ASSERTIONS)
WHICH OPTION? INPUT
ON OR OFF? ON
*
LISTENING---> GO
QUIT
READY
PICK UP A BIG RED BLOCK.

>>>
LISTENING---> SH NODE C

[NODE3]
   PARENT         (NODE1)
   SEMANTICS      NIL
   DAUGHTERS      (NODE4)
   WORDAFTER      (UP A BIG RED BLOCK)
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (VG IMPER)

>>>
LISTENING---> SHOW NODE C

[NODE6]
   PARENT         (NODE1)
   SEMANTICS      NIL
   DAUGHTERS      (NODE12 NODE11 NODE10 NODE7)
   WORDAFTER      NIL
   FIRSTWORD      (A BIG RED BLOCK)
   FEATURES       (INDEF NS DET OBJ1 OBJ NG)

[OSS1]
   OSSNODE=       OSS1
   PARSENODE=     (NODE6)
   VARIABLE=      X1
   DETERMINER=    (NS INDEF NIL)

>>>
LISTENING---> SH CU

A BIG RED BLOCK
*
LISTENING---> 

[OSS2]
   OSSNODE=       OSS2
   PARSENODE=     (NODE6)
   VARIABLE=      X1
   RELATIONS=     ((#IS OSS1 #BLOCK))
   DETERMINER=    (NS INDEF NIL)
   PLAUSIBILITY= 0
   SYSTEMS=       (#SHAPES #PHYSOB #THING #SYSTEMS)
   MARKERS=       (#SHAPES #RECTANGULAR
                           #SYSTEMS
                           #THING
                           #PHYSOB
                           #MANIP)

>>>
LISTENING---> SHOW MA #SHAPES

#SHAPES
*
LISTENING---> SHOW MA #PHYSOB

#PHYSOB
       #BOX
       #CONSTRUCT
               #STACK
               #ROW
       #HAND
       #MANIP
       #TABLE
*
LISTENING---> 

[OSS3]
   OSSNODE=       OSS3
   PARSENODE=     (NODE6)
   VARIABLE=      X1
   RELATIONS=     ((#COLOR OSS2 #RED)
                   (#IS OSS1 #BLOCK))
   DETERMINER=    (NS INDEF NIL)
   PLAUSIBILITY=  0
   SYSTEMS=     (#SPECTRUM #SHAPES
                           #PHYSOB
                           #THING
                           #SYSTEMS)
   MARKERS=       (#SPECTRUM #RED
                             #SHAPES
                             #RECTANGULAR
                             #SYSTEMS
                             #THING
                             #PHYSOB
                             #MANIP)

>>>
LISTENING---> 

[OSS4]
   OSSNODE=       OSS4
   PARSENODE=     (NODE6)
   VARIABLE=      X1
   RELATIONS=     ((#MORE #SIZE OSS3 (200 200 200))
                   (#COLOR OSS2 #RED)
                   (#IS OSS1 #BLOCK))
   DETERMINER=    (NS INDEF NIL)
   PLAUSIBILITY= 0
   SYSTEMS=       (#SPECTRUM #SHAPES
                             #PHYSOB
                             #THING
                             #SYSTEMS)
   MARKERS=       (#BIG #SPECTRUM
                        #RED
                        #SHAPES
                        #RECTANGULAR
                        #SYSTEMS
                        #THING
                        #PHYSOB
                        #MANIP)

>>>
LISTENING---> SHOW NODE C

[NODE1]
   MVB            (PICK-UP)
   TIME   TSS1
   PARENT         NIL
   SEMANTICS      NIL
   DAUGHTERS      (NODE6 NODE5 NODE3)
   WORDAFTER      NIL
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (PRT ACTV
                       IMPER
                       TOPLEVEL
                       MAJOR
                       CLAUSE)

[RSS1]
   PARSENODE=     (NODE1)
   RSSNODE=       RSS1
   VARIABLE=      EVX1
   RELATIONS=     ((#PICKUP OSS4 TSS1))
   PLAUSIBILITY= 0
   SYSTEMS=       (#SYSTEMS)
   MARKERS=       (#SYSTEMS #EVENT)

>>>
LISTENING---> SH NODE C

[NODE1]
   OBJ1   (NODE6 NODE5 NODE3)
   MVB            (PICK-UP)
   TIME   TSS1
   PARENT         NIL
   SEMANTICS      (RSS1)
   DAUGHTERS      (NODE6 NODE5 NODE3)
   WORDAFTER      NIL
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (CLAUSE MAJOR
                          TOPLEVEL
                          IMPER
                          ACTV
                          PRT
                          TRANS)

>>>
LISTENING---> SHOW TREE C

(((PICK UP A BIG RED BLOCK)
  (CLAUSE MAJOR TOPLEVEL IMPER ACTV PRT TRANS)
  (RSS1)
  (((PICK) (VG IMPER) NIL ((PICK (VPRT VB INF TRANS MVB))))
   (UP (PRT))
   ((A BIG RED BLOCK)
    (NG OBJ OBJ1 DET NS INDEF)
    (OSS4)
    ((A (DET NS INDEF)) (BIG (ADJ)) (RED (ADJ)) (BLOCK (NOUN NS))))))
 NIL)
*
LISTENING---> 

(THAND (THGOAL (#PICKUP OSS4) (THDBF MUMBLE) (THUSE TC-2))
        (VALUEPUT)
        (SETQ SUCCESS T)
        (SETQ PLAN2 PLAN))
>>>  FOR PLANNER
OK.

APPENDIX 4
----------

THIS IS THE INFERENCE TRACE FOR "PICK UP A BIG RED BLOCK."
===============================================================
 ]--> LOADING SHRDLU
         <CONTROL N> GETS BACK TO ZOG
>>> SHRDLU COMMAND STATE, TYPE HELP <CR> FOR INSTRUCTIONS.
LISTENING---> SHOW

(SHOW TELL LISP PLANNER PARSING DEFINITIONS INPUT)
WHICH OPTION? SHOW
CANSHOW
       SHOW
       TELL
       LISP
               PROPERTY
               FUNCTION
               VALUE
       PLANNER
               ASSERTIONS
               THEOREM
               SCENE
       PARSING
               NODE
               TREE
       DEFINITIONS
               UNIT
               WORD
               MARKER
       INPUT
               ALL
               REST
               CURRENT
*
LISTENING---> SHOW SCENE
  CURRENT SCENE

:B1 -->  A SMALL RED BLOCK  AT (110 100 0)SUPPORTS (:B2)
:B2 -->  A SMALL GREEN PYRAMID  AT (110 100 100)
:B3 -->  A LARGE GREEN BLOCK  AT (400 0 0)SUPPORTS (:B5)
:B4 -->  A LARGE BLUE PYRAMID  AT (640 640 1)
:B5 -->  A SMALL RED PYRAMID  AT (500 100 200)
:B6 -->  A LARGE RED BLOCK  AT (0 300 0)SUPPORTS (:B7)
:B7 -->  A LARGE GREEN BLOCK  AT (0 240 300)
:B10 -->  A LARGE BLUE BLOCK  AT (300 640 0)
:BOX -->  A LARGE WHITE BOX  AT (600 600 0)SUPPORTS (:B4)
THE HAND IS GRASPING  NOTHING
*
LISTENING---> TELL PARSING OFF
*
LISTENING---> TELL SEMANTICS

DO SEMANTIC ANALYSIS? YES
SHOW BUILDING OF SEMANTIC STRUCTURES? NO
*
LISTENING---> TELL PLANNER OFF
*
LISTENING---> GO
QUIT
READY
PICK UP A BIG RED BLOCK.

*
LISTENING---> 

(THAND (THGOAL (#PICKUP OSS4) (THDBF MUMBLE) (THUSE TC-2))
        (VALUEPUT)
        (SETQ SUCCESS T)
        (SETQ PLAN2 PLAN))
>>>  FOR PLANNER
LISTENING---> 
>>>  ENTERING FINDCHOOSE EXPR (OSS X ANS2)

*
LISTENING---> SHOW VALUE OSS

OSS4
*
LISTENING---> 
>>>  EXITING FINDCHOOSE
LISTENING---> SHOW VALUE X

:B6
*
LISTENING---> SHOW PLANNER

(ASSERTIONS THEOREM SCENE)
WHICH OPTION? ASSERTIONS
ATOM: ?

SHOW ALL ASSERTIONS WHICH CONTAIN THE GIVEN ATOM
ATOM: :B6

(((#COLOR :B6 #RED)) ((#SHAPE :B6 #RECTANGULAR))
                      ((#SUPPORT :B6 :B7))
                      ((#AT :B6 (0 300 0)))
                      ((#IS :B6 #BLOCK))
                      ((#MANIP :B6))
                      ((#SUPPORT :TABLE :B6)))
*
LISTENING---> TELL PLANNER ON

*
LISTENING---> 
TRYING GOAL G1 (#PICKUP :B6)
>>>
LISTENING---> 
ENTERING THEOREM TC-PICKUP
TRYING GOAL G2 (#GRASP :B6)
>>>
LISTENING---> SHOW THEOREM TC-PICKUP

(THCONSE (X (WHY (EV)) EV) (#PICKUP $?X)
          (MEMORY)

          (THGOAL (#GRASP $?X) (THUSE TC-GRASP))
          (THGOAL (#RAISEHAND) (THNODB) (THUSE TC-RAISEHAND))
          (MEMOREND (#PICKUP $?EV $?X)))
*
ENTERING THEOREM TC-GRASP
TRYING GOAL G3 (#GRASPING :B6)
G3 FAILED
TRYING GOAL G4 (#CLEARTOP :B6)
ENTERING THEOREM TC-CLEARTOP
TRYING GOAL G5 (#SUPPORT :B6 ?)
G5 SUCCEEDED ((#SUPPORT :B6 :B7))
TRYING GOAL G6 (#SUPPORT :B6 (THNV Y))
G6 SUCCEEDED ((#SUPPORT :B6 :B7))
TRYING GOAL G7 (#GET-RID-OF :B7)
ENTERING THEOREM TC-GET-RID-OF
TRYING GOAL G10 (#FINDSPACE :TABLE (200 200 200) :B7 (THNV Y))
ENTERING THEOREM TC-FINDSPACE
TC-FINDSPACE SUCCEEDED THNOVAL
G10 SUCCEEDED
ENTERING THEOREM TC-PUT
TRYING GOAL G12 (#GRASP :B7)
ENTERING THEOREM TC-GRASP

TRYING GOAL G13 (#GRASPING :B7)
G13 FAILED
TRYING GOAL G14 (#CLEARTOP :B7)
G14 SUCCEEDED ((#CLEARTOP :B7))
TRYING GOAL G15 (#GRASPING (THNV Y))
G15 FAILED
TRYING GOAL G16 (#MOVEHAND2 (100 340 500))
ENTERING THEOREM TC-MOVEHAND2
TC-MOVEHAND2 SUCCEEDED THNOVAL
G16 SUCCEEDED (#MOVEHAND2 (100 340 500))
ASSERTING A17 (#GRASPING :B7)
A17 SUCCEEDED
ASSERTING A20 (#GRASP E5 :B7)
A20 SUCCEEDED
TC-GRASP SUCCEEDED THNOVAL
G12 SUCCEEDED (#GRASP :B7)
>>>
LISTENING---> SHOW PR E5

[E5]
   TYPE   #GRASP
   THASSERTION    (NIL (2 (3 1 ((#GRASP E5 :B7)))))
   END            1
   WHY            E4
   START          0

*
TRYING GOAL G21 (#MOVEHAND (600 374 200))
ENTERING THEOREM TC-MOVEHAND
TRYING GOAL G22 (#GRASPING (THV X))
G22 SUCCEEDED ((#GRASPING :B7))
TRYING GOAL G23 (#AT :B7 (THNV W))
G23 SUCCEEDED ((#AT :B7 (0 240 300)))
ERASING E24 (#AT :B7 (0 240 300))
ENTERING THEOREM TE-SUPP
TRYING GOAL G25 (#SUPPORT :B7 (THNV Y))
G25 FAILED
TRYING GOAL G26 (#SUPPORT (THNV Y) :B7)
G26 SUCCEEDED ((#SUPPORT :B6 :B7))
ERASING E27 (#SUPPORT :B6 :B7)
E27 SUCCEEDED
TRYING GOAL G30 (#PART :B7 (THNV Y))
G30 FAILED
TE-SUPP SUCCEEDED THNOVAL
ENTERING THEOREM TE-CONTAIN
TRYING GOAL G31 (#CONTAIN (THNV Y) :B7)
G31 FAILED
TE-CONTAIN FAILED
E24 SUCCEEDED
ASSERTING A32 (#AT :B7 (500 274 0))
ENTERING THEOREM TA-AT
TA-AT SUCCEEDED THNOVAL
ENTERING THEOREM TA-SUPP
TRYING GOAL G33 (#MANIP :TABLE)
G33 FAILED
ASSERTING A34 (#SUPPORT :TABLE :B7)
A34 SUCCEEDED
TRYING GOAL G35 (#CLEARTOP :TABLE)
G35 FAILED
TA-SUPP SUCCEEDED THNOVAL
ENTERING THEOREM TA-CONTAIN
TRYING GOAL G36 (#MANIP :B7)
G36 SUCCEEDED ((#MANIP :B7))
TRYING GOAL G37 (#SUPPORT (THV Y) :B7)
G37 SUCCEEDED ((#SUPPORT :TABLE :B7))
TRYING GOAL G40 (#IS :TABLE #BOX)
G40 FAILED
TRYING GOAL G41 (#CONTAIN (THV Z) :TABLE)
G41 FAILED
G37 FAILED
G36 FAILED
TA-CONTAIN FAILED

A32 SUCCEEDED
TRYING GOAL G42 (#MOVEHAND2 (600 374 200))
ENTERING THEOREM TC-MOVEHAND2
TC-MOVEHAND2 SUCCEEDED THNOVAL
G42 SUCCEEDED (#MOVEHAND2 (600 374 200))
TRYING GOAL G43 (#SUPPORT (THV Y) :B7)
G43 SUCCEEDED ((#SUPPORT :TABLE :B7))
TC-MOVEHAND SUCCEEDED THNOVAL
G21 SUCCEEDED (#MOVEHAND (600 374 200))
TRYING GOAL G44 (#UNGRASP)
ENTERING THEOREM TC-UNGRASP
TRYING GOAL G45 (#GRASPING (THV X))
G45 SUCCEEDED ((#GRASPING :B7))
TRYING GOAL G46 (#SUPPORT ? :B7)
G46 SUCCEEDED ((#SUPPORT :TABLE :B7))
ERASING E47 (#GRASPING :B7)
E47 SUCCEEDED
ASSERTING A50 (#UNGRASP E6 :B7)
A50 SUCCEEDED
TC-UNGRASP SUCCEEDED THNOVAL
G44 SUCCEEDED (#UNGRASP)
TC-PUT SUCCEEDED THNOVAL
G11 SUCCEEDED (#PUT :B7 (500 274 0))
ASSERTING A51 (#GET-RID-OF E4 :B7)
A51 SUCCEEDED
TC-GET-RID-OF SUCCEEDED THNOVAL
G7 SUCCEEDED (#GET-RID-OF :B7)
TRYING GOAL G52 (#SUPPORT :B6 (THNV Y))
G52 FAILED
ASSERTING A53 (#CLEARTOP :B6)
A53 SUCCEEDED
ASSERTING A54 (#CLEARTOP E3 :B6)
A54 SUCCEEDED
TC-CLEARTOP SUCCEEDED THNOVAL
G4 SUCCEEDED (#CLEARTOP :B6)
>>>
LISTENING---> SHOW EVENT E3

E3  (#CLEARTOP E3 :B6)  --  TIME0 TO 3
    E6  (#UNGRASP E6 :B7)  --  TIME2 TO 2
    E4  (#GET-RID-OF E4 :B7)  --  TIME0 TO 3
         E5  (#GRASP E5 :B7)  --  TIME0 TO 1
*
TRYING GOAL G55 (#GRASPING (THNV Y))
G55 FAILED
TRYING GOAL G56 (#MOVEHAND2 (100 440 300))
ENTERING THEOREM TC-MOVEHAND2
TC-MOVEHAND2 SUCCEEDED THNOVAL
G56 SUCCEEDED (#MOVEHAND2 (100 440 300))
ASSERTING A57 (#GRASPING :B6)
A57 SUCCEEDED
ASSERTING A60 (#GRASP E2 :B6)
A60 SUCCEEDED
TC-GRASP SUCCEEDED THNOVAL
G2 SUCCEEDED (#GRASP :B6)
TRYING GOAL G61 (#RAISEHAND)
ENTERING THEOREM TC-RAISEHAND
TRYING GOAL G62 (#MOVEHAND (100 440 1000))
>>>
LISTENING---> TELL PL

(INPUT ACTION THEOREM ASSERTIONS)
WHICH OPTION? ACTION
ON OR OFF? OFF

*
LISTENING---> TELL ACTION (THASSERT)

*
ASSERTING A63 (#AT :B6 (0 300 500))
A63 SUCCEEDED
G62 SUCCEEDED (#MOVEHAND (100 440 1000))
ASSERTING A64 (#RAISEHAND E7)
A64 SUCCEEDED  SUCCEEDED (#RAISEHAND)
ASSERTING A65 (#PICKUP E1 :B6)
A65 SUCCEEDED
TC-PICKUP SUCCEEDED THNOVAL

G1 SUCCEEDED (#PICKUP :B6)
>>>
LISTENING---> SHOW EVENT E1

E1  (#PICKUP E1 :B6)  --  TIME 0 TO 5
    E2  (#GRASP E2 :B6)  --  TIME 0 TO 4
         E3  (#CLEARTOP E3 :B6)  --  TIME 0 TO 3
              E4  (#GET-RID-OF E4 :B7)  --  TIME 0 TO 3
                   E5  (#GRASP E5 :B7)  --  TIME 0 TO 1
              E6  (#UNGRASP E6 :B7)  --  TIME 2 TO 2
    E7  (#RAISEHAND E7)  --  TIME 4 TO 5
(EE LISTENING---> 

[ANS1]
   ACTION=        ((MOVETO 100 340 500) (GRASP ':B7)
                                        (MOVETO 600 374 200)
                                        (UNGRASP)
                                        (MOVETO 100 440 300)
                                        (GRASP ':B6)
                                        (MOVETO 100 440 1000)
                                        (SAY OK))
   ANSRSS=        RSS1
   ANSNODE=       ANS1
   PLAUSIBILITY= 0

*
MOVETO (100 340 500)
GRASP :B7
MOVETO (600 374 200)
UNGRASP
MOVETO (100 440 300)
GRASP :B6
MOVETO (100 440 1000)OK .

APPENDIX 5
----------

 THIS IS ALL THREE TRACES COMBINED FOR "PICK UP A BIG RED BLOCK."
(I.E. PARSING, SEMANTIC STRUCTURES AND INFERENCE)
=================================================================
>SHRDLU RUN!
>>> SHRDLU COMMAND STATE, TYPE HELP <CR> FOR INSTRUCTIONS.
LISTENING---> SHOW

(SHOW TELL LISP PLANNER PARSING DEFINITIONS INPUT)
WHICH OPTION? SHOW
CANSHOW
       SHOW
       TELL
       LISP
               PROPERTY
               FUNCTION
               VALUE
       PLANNER
               ASSERTIONS
               THEOREM
               SCENE
       PARSING
               NODE
               TREE
       DEFINITIONS
               UNIT
               WORD
               MARKER
       INPUT
               ALL
               REST
               CURRENT
*
LISTENING---> SHOW SCENE
  CURRENT SCENE

:B1 -->  A SMALL RED BLOCK  AT (110 100 0)SUPPORTS (:B2)
:B2 -->  A SMALL GREEN PYRAMID  AT (110 100 100)
:B3 -->  A LARGE GREEN BLOCK  AT (400 0 0)SUPPORTS (:B5)
:B4 -->  A LARGE BLUE PYRAMID  AT (640 640 1)
:B5 -->  A SMALL RED PYRAMID  AT (500 100 200)
:B6 -->  A LARGE RED BLOCK  AT (0 300 0)SUPPORTS (:B7)
:B7 -->  A LARGE GREEN BLOCK  AT (0 240 300)
:B10 -->  A LARGE BLUE BLOCK  AT (300 640 0)
:BOX -->  A LARGE WHITE BOX  AT (600 600 0)SUPPORTS (:B4)
THE HAND IS GRASPING  NOTHING
*
LISTENING---> TELL PARSING

(NODE LABEL ATTEMPT)
WHICH OPTION? NODE
ON OR OFF? ON

*
LISTENING---> TELL LABEL ON

*
LISTENING---> TELL SEMANTICS

DO SEMANTIC ANALYSIS? YES
SHOW BUILDING OF SEMANTIC STRUCTURES? YES
*
LISTENING---> TELL PLANNER OFF

*
LISTENING---> TELL PL

(INPUT ACTION THEOREM ASSERTIONS)
WHICH OPTION? INPUT
ON OR OFF? ON
*
LISTENING---> TE FUNCTION FINDCHOOSE

TRACE BREAK UNTRACE OR UNBREAK? BREAK
FINDCHOOSE
*
LISTENING---> GO
QUIT
READY
PICK UP A BIG RED BLOCK.

[1]

[NODE1]
   SEMANTICS      NIL
   DAUGHTERS      NIL
   WORDAFTER      (PICK UP A BIG RED BLOCK)
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (TOPLEVEL MAJOR CLAUSE)

>>>
LISTENING--->TE AT ON

*
LISTENING---> 
PASSING ENTERING-CLAUSE

[TSS1]
   TSSNODE=       TSS1

>>>
LISTENING---> 
PASSING INIT
PASSING MAJOR
PASSING THEREINIT
PASSING THER2
(1 ENTER PARSE (NG TIME))

[NODE2]
   SEMANTICS      NIL
   DAUGHTERS      NIL
   WORDAFTER      (PICK UP A BIG RED BLOCK)
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (TIME NG)

>>>
LISTENING---> 
PASSING ENTERING-NG
PASSING NGSTART
PASSING TIME
PASSING FAIL
(1 EXIT PARSE NIL)
PASSING CLAUSETYPE
(1 ENTER PARSE (VG IMPER))

[NODE3]
   SEMANTICS      NIL
   DAUGHTERS      NIL

   WORDAFTER      (PICK UP A BIG RED BLOCK)
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (IMPER VG)

>>>
LISTENING---> 
PASSING ENTERING-VG
PASSING IMPER
(2 ENTER PARSE (VB DO NEG INF))
(2 EXIT PARSE NIL)
(2 ENTER PARSE (VB (MVB) INF))

[NODE4]
   SEMANTICS      ((TRANS (#NOTICE)))
   DAUGHTERS      WORD
   WORDAFTER      (UP A BIG RED BLOCK)
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (VPRT VB INF TRANS MVB)

>>>
LISTENING---> 

[NODE3]
   PARENT         (NODE1)
   SEMANTICS      NIL
   DAUGHTERS      (NODE4)
   WORDAFTER      (UP A BIG RED BLOCK)
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (IMPER VG)

>>>
LISTENING---> 
(2 EXIT PARSE (NODE3))
PASSING RETURN

[NODE3]
   PARENT         (NODE1)
   SEMANTICS      NIL
   DAUGHTERS      (NODE4)
   WORDAFTER      (UP A BIG RED BLOCK)
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (VG IMPER)

>>>
LISTENING---> 

[NODE1]
   MVB            (NODE4)
   TIME   TSS1
   PARENT         NIL
   SEMANTICS      NIL
   DAUGHTERS      (NODE3)
   WORDAFTER      (UP A BIG RED BLOCK)
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (TOPLEVEL MAJOR CLAUSE)

>>>
LISTENING---> 
(1 EXIT PARSE (NODE3))
PASSING VG1
(1 ENTER PARSE (PRT))

[NODE5]
   SEMANTICS      T
   DAUGHTERS      WORD
   WORDAFTER      (A BIG RED BLOCK)
   FIRSTWORD      (UP A BIG RED BLOCK)
   FEATURES       (PRT)

>>>
LISTENING---> 

[NODE1]
   MVB            (NODE4)
   TIME   TSS1
   PARENT         NIL
   SEMANTICS      NIL
   DAUGHTERS      (NODE5 NODE3)
   WORDAFTER      (A BIG RED BLOCK)
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (ACTV IMPER TOPLEVEL MAJOR CLAUSE)

>>>
LISTENING---> SHOW TREE

NODE-SPECIFICATION: C
(((PICK UP) (ACTV IMPER TOPLEVEL MAJOR CLAUSE)
             NIL
             (((PICK) (VG IMPER) NIL ((PICK (VPRT VB INF TRANS MVB))))
              (UP (PRT))))
 NIL)
*
LISTENING--->
(1 EXIT PARSE (NODE1))
PASSING TRANSP
(1 ENTER PARSE (NG OBJ OBJ1))

[NODE6]
   SEMANTICS      NIL
   DAUGHTERS      NIL
   WORDAFTER      (A BIG RED BLOCK)
   FIRSTWORD      (A BIG RED BLOCK)
   FEATURES       (OBJ1 OBJ NG)

>>>
LISTENING---> 
PASSING ENTERING-NG
PASSING NGSTART
PASSING LOOK
PASSING DET
(2 ENTER PARSE (DET))

[NODE7]
   SEMANTICS      T
   DAUGHTERS      WORD
   WORDAFTER     (A BIG RED BLOCK)

   FIRSTWORD      (A BIG RED BLOCK)
   FEATURES       (DET NS INDEF)

>>>
LISTENING---> 

[NODE6]
   PARENT         (NODE1)
   SEMANTICS      NIL
   DAUGHTERS      (NODE7)
   WORDAFTER      (BIG RED BLOCK)
   FIRSTWORD      (A BIG RED BLOCK)
   FEATURES       (OBJ1 OBJ NG)

>>>
LISTENING---> 
(2 EXIT PARSE (NODE6))
PASSING IND
PASSING ADJ
(2 ENTER PARSE (ADJ))

[NODE10]
   SEMANTICS      (OBJECT
                      (MARKERS: (#PHYSOB #BIG)
                       PROCEDURE: ((#MORE #SIZE
                                          ***
                                          (200 200
                                               200)))))
   DAUGHTERS      WORD
   WORDAFTER      (RED BLOCK)
   FIRSTWORD      (BIG RED BLOCK)
   FEATURES       (ADJ)

>>>
LISTENING---> 

[NODE6]
   PARENT         (NODE1)
   SEMANTICS      NIL
   DAUGHTERS      (NODE10 NODE7)
   WORDAFTER      (RED BLOCK)
   FIRSTWORD      (A BIG RED BLOCK)
   FEATURES       (INDEF NS DET OBJ1 OBJ NG)

>>>
LISTENING---> 
(2 EXIT PARSE (NODE6))
PASSING ADJ
(2 ENTER PARSE (ADJ))

[NODE11]
   SEMANTICS      (#COLOR #RED)
   DAUGHTERS      WORD
   WORDAFTER      (BLOCK)
   FIRSTWORD      (RED BLOCK)
   FEATURES       (ADJ)

>>>
LISTENING---> 

[NODE6]
   PARENT         (NODE1)
   SEMANTICS      NIL
   DAUGHTERS      (NODE11 NODE10 NODE7)
   WORDAFTER      (BLOCK)
   FIRSTWORD      (A BIG RED BLOCK)
   FEATURES       (INDEF NS DET OBJ1 OBJ NG)

>>>
LISTENING---> SHOW CURRENT

A BIG RED
*
LISTENING---> 
(2 EXIT PARSE (NODE6))
PASSING ADJ
(2 ENTER PARSE (ADJ))
(2 EXIT PARSE NIL)
PASSING CLASF
(2 ENTER PARSE (VB ING (CLASF)))
(2 EXIT PARSE NIL)
(2 ENTER PARSE (VB EN (CLASF)))
(2 EXIT PARSE NIL)
(2 ENTER PARSE (CLASF))
(2 EXIT PARSE NIL)
PASSING NOUN
(2 ENTER PARSE (NOUN))

[NODE12]
   SEMANTICS      (OBJECT
                      (MARKERS: (#MANIP
                                 #RECTANGULAR)
                       PROCEDURE: ((#IS *** #BLOCK))))
   DAUGHTERS      WORD
   WORDAFTER      NIL
   FIRSTWORD      (BLOCK)

   FEATURES       (NOUN NS)

>>>
LISTENING---> 

[NODE6]
   PARENT         (NODE1)
   SEMANTICS      NIL
   DAUGHTERS      (NODE12 NODE11 NODE10 NODE7)
   WORDAFTER      NIL
   FIRSTWORD      (A BIG RED BLOCK)
   FEATURES       (INDEF NS DET OBJ1 OBJ NG)

>>>
LISTENING---> 
(2 EXIT PARSE (NODE6))
PASSING SMNG
(1 ENTER CALLSM ((SMNG1)))

[OSS1]
   OSSNODE=       OSS1
   PARSENODE=     (NODE6)
   VARIABLE=      X1
   DETERMINER=    (NS INDEF NIL)

>>>
LISTENING---> SH CU

A BIG RED BLOCK
*
LISTENING---> 

[OSS2]
   OSSNODE=       OSS2
   PARSENODE=     (NODE6)
   VARIABLE=      X1
   RELATIONS=     ((#IS OSS1 #BLOCK))
   DETERMINER=    (NS INDEF NIL)
   PLAUSIBILITY= 0
   SYSTEMS=       (#SHAPES #PHYSOB #THING #SYSTEMS)
   MARKERS=       (#SHAPES #RECTANGULAR
                           #SYSTEMS
                           #THING
                           #PHYSOB
                           #MANIP)

>>>
LISTENING---> SHOW MA #SHAPES

#SHAPES
*
LISTENING---> SHOW MA #PHYSOB

#PHYSOB
       #BOX
       #CONSTRUCT
               #STACK
               #ROW
       #HAND
       #MANIP
       #TABLE
*
LISTENING---> 

[OSS3]
   OSSNODE=       OSS3
   PARSENODE=     (NODE6)
   VARIABLE=      X1
   RELATIONS=     ((#COLOR OSS2 #RED)
                   (#IS OSS1 #BLOCK))
   DETERMINER=    (NS INDEF NIL)
   PLAUSIBILITY=  0
   SYSTEMS=     (#SPECTRUM #SHAPES
                           #PHYSOB
                           #THING
                           #SYSTEMS)
   MARKERS=       (#SPECTRUM #RED
                             #SHAPES
                             #RECTANGULAR
                             #SYSTEMS
                             #THING
                             #PHYSOB
                             #MANIP)

>>>
LISTENING---> 

[OSS4]
   OSSNODE=       OSS4
   PARSENODE=     (NODE6)
   VARIABLE=      X1
   RELATIONS=     ((#MORE #SIZE OSS3 (200 200 200))
                   (#COLOR OSS2 #RED)
                   (#IS OSS1 #BLOCK))
   DETERMINER=    (NS INDEF NIL)
   PLAUSIBILITY= 0
   SYSTEMS=       (#SPECTRUM #SHAPES
                             #PHYSOB
                             #THING
                             #SYSTEMS)
   MARKERS=       (#BIG #SPECTRUM
                        #RED
                        #SHAPES
                        #RECTANGULAR
                        #SYSTEMS
                        #THING
                        #PHYSOB
                        #MANIP)

>>>
LISTENING---> 
(1 EXIT CALLSM (OSS4))
PASSING RETSM
(1 ENTER CALLSM ((SMNG2)))
(1 EXIT CALLSM (OSS4))
PASSING RETURN

[NODE6]
   HEAD   (NODE12 NODE11 NODE10 NODE7)
   PARENT         (NODE1)
   SEMANTICS      (OSS4)
   DAUGHTERS      (NODE12 NODE11 NODE10 NODE7)
   WORDAFTER      NIL
   FIRSTWORD      (A BIG RED BLOCK)

   FEATURES       (NG OBJ OBJ1 DET NS INDEF)

>>>
LISTENING---> 

[NODE1]
   MVB            (PICK-UP)
   TIME   TSS1
   PARENT         NIL
   SEMANTICS      NIL
   DAUGHTERS      (NODE6 NODE5 NODE3)
   WORDAFTER      NIL
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (PRT ACTV
                       IMPER
                       TOPLEVEL
                       MAJOR
                       CLAUSE)

>>>
LISTENING---> SHOW WORD PICK-UP

[PICK-UP]
   FEATURES       (COMBINATION TRANS)
   SEMANTICS      ((TRANS
                    (RELATION
                        (RESTRICTIONS: (((#ANIMATE))
                                        ((#MANIP)))
                         MARKERS: (#EVENT)
                         PROCEDURE: ((#EVAL
                                      (COND
                                       ((MEMQ (NUMBER? SMOB1)
                                              '(1 NS))
                                        '(#PICKUP #2 *TIME))
                                       ('(#PUTIN
                                          #2
                                          :BOX
                                          *TIME)))))))))
   ROOT   (PICK UP)

>>>
LISTENING---> 
*
LISTENING---> 
(1 EXIT PARSE (NODE6))
PASSING OBB
PASSING FQPRT
PASSING ONT
(1 ENTER CALLSM ((SMCL1)))

[RSS1]
   PARSENODE=     (NODE1)
   RSSNODE=       RSS1
   VARIABLE=      EVX1
   RELATIONS=     ((#PICKUP OSS4 TSS1))
   PLAUSIBILITY= 0
   SYSTEMS=       (#SYSTEMS)
   MARKERS=       (#SYSTEMS #EVENT)

>>>
LISTENING---> 
(1 EXIT CALLSM (RSS1))
PASSING RETSM
(1 ENTER CALLSM ((SMCL2)))
(1 EXIT CALLSM (NODE6 NODE5 NODE3))
PASSING RETURN

[NODE1]
   OBJ1   (NODE6 NODE5 NODE3)
   MVB            (PICK-UP)
   TIME   TSS1
   PARENT         NIL
   SEMANTICS      (RSS1)
   DAUGHTERS      (NODE6 NODE5 NODE3)
   WORDAFTER      NIL
   FIRSTWORD      (PICK UP A BIG RED BLOCK)
   FEATURES       (CLAUSE MAJOR
                          TOPLEVEL
                          IMPER
                          ACTV
                          PRT
                          TRANS)

>>>
LISTENING---> SHOW TREE C

(((PICK UP A BIG RED BLOCK)
  (CLAUSE MAJOR TOPLEVEL IMPER ACTV PRT TRANS)
  (RSS1)
  (((PICK) (VG IMPER) NIL ((PICK (VPRT VB INF TRANS MVB))))
   (UP (PRT))
   ((A BIG RED BLOCK)
    (NG OBJ OBJ1 DET NS INDEF)
    (OSS4)
    ((A (DET NS INDEF)) (BIG (ADJ)) (RED (ADJ)) (BLOCK (NOUN NS))))))
 NIL)
*
LISTENING---> 

(THAND (THGOAL (#PICKUP OSS4) (THDBF MUMBLE) (THUSE TC-2))
        (VALUEPUT)
        (SETQ SUCCESS T)
        (SETQ PLAN2 PLAN))
>>>  FOR PLANNER
LISTENING---> 
>>>  ENTERING FINDCHOOSE EXPR (OSS X ANS2)

*
LISTENING---> SHOW VALUE OSS

OSS4
*
LISTENING---> 
>>>  EXITING FINDCHOOSE
LISTENING---> SHOW VALUE X

:B6
*
LISTENING---> SHOW PLANNER

(ASSERTIONS THEOREM SCENE)
WHICH OPTION? ASSERTIONS
ATOM: ?

SHOW ALL ASSERTIONS WHICH CONTAIN THE GIVEN ATOM
ATOM: :B6

(((#COLOR :B6 #RED)) ((#SHAPE :B6 #RECTANGULAR))
                      ((#SUPPORT :B6 :B7))
                      ((#AT :B6 (0 300 0)))
                      ((#IS :B6 #BLOCK))
                      ((#MANIP :B6))
                      ((#SUPPORT :TABLE :B6)))
*
LISTENING---> TELL PLANNER ON

*
LISTENING---> 
TRYING GOAL G1 (#PICKUP :B6)
>>>
LISTENING---> 
ENTERING THEOREM TC-PICKUP
TRYING GOAL G2 (#GRASP :B6)
>>>
LISTENING---> SHOW THEOREM TC-PICKUP

(THCONSE (X (WHY (EV)) EV) (#PICKUP $?X)
          (MEMORY)

          (THGOAL (#GRASP $?X) (THUSE TC-GRASP))
          (THGOAL (#RAISEHAND) (THNODB) (THUSE TC-RAISEHAND))
          (MEMOREND (#PICKUP $?EV $?X)))
*
ENTERING THEOREM TC-GRASP
TRYING GOAL G3 (#GRASPING :B6)
G3 FAILED
TRYING GOAL G4 (#CLEARTOP :B6)
ENTERING THEOREM TC-CLEARTOP
TRYING GOAL G5 (#SUPPORT :B6 ?)
G5 SUCCEEDED ((#SUPPORT :B6 :B7))
TRYING GOAL G6 (#SUPPORT :B6 (THNV Y))
G6 SUCCEEDED ((#SUPPORT :B6 :B7))
TRYING GOAL G7 (#GET-RID-OF :B7)
ENTERING THEOREM TC-GET-RID-OF
TRYING GOAL G10 (#FINDSPACE :TABLE (200 200 200) :B7 (THNV Y))
ENTERING THEOREM TC-FINDSPACE
TC-FINDSPACE SUCCEEDED THNOVAL
G10 SUCCEEDED
ENTERING THEOREM TC-PUT
TRYING GOAL G12 (#GRASP :B7)
ENTERING THEOREM TC-GRASP

TRYING GOAL G13 (#GRASPING :B7)
G13 FAILED
TRYING GOAL G14 (#CLEARTOP :B7)
G14 SUCCEEDED ((#CLEARTOP :B7))
TRYING GOAL G15 (#GRASPING (THNV Y))
G15 FAILED
TRYING GOAL G16 (#MOVEHAND2 (100 340 500))
ENTERING THEOREM TC-MOVEHAND2
TC-MOVEHAND2 SUCCEEDED THNOVAL
G16 SUCCEEDED (#MOVEHAND2 (100 340 500))
ASSERTING A17 (#GRASPING :B7)
A17 SUCCEEDED
ASSERTING A20 (#GRASP E5 :B7)
A20 SUCCEEDED
TC-GRASP SUCCEEDED THNOVAL
G12 SUCCEEDED (#GRASP :B7)
>>>
LISTENING---> SHOW PR E5

[E5]
   TYPE   #GRASP
   THASSERTION    (NIL (2 (3 1 ((#GRASP E5 :B7)))))
   END            1
   WHY            E4
   START          0

*
TRYING GOAL G21 (#MOVEHAND (600 374 200))
ENTERING THEOREM TC-MOVEHAND
TRYING GOAL G22 (#GRASPING (THV X))
G22 SUCCEEDED ((#GRASPING :B7))

TRYING GOAL G23 (#AT :B7 (THNV W))
G23 SUCCEEDED ((#AT :B7 (0 240 300)))
ERASING E24 (#AT :B7 (0 240 300))
ENTERING THEOREM TE-SUPP
TRYING GOAL G25 (#SUPPORT :B7 (THNV Y))
G25 FAILED
TRYING GOAL G26 (#SUPPORT (THNV Y) :B7)
G26 SUCCEEDED ((#SUPPORT :B6 :B7))
ERASING E27 (#SUPPORT :B6 :B7)
E27 SUCCEEDED
TRYING GOAL G30 (#PART :B7 (THNV Y))
G30 FAILED
TE-SUPP SUCCEEDED THNOVAL
ENTERING THEOREM TE-CONTAIN
TRYING GOAL G31 (#CONTAIN (THNV Y) :B7)
G31 FAILED
TE-CONTAIN FAILED
E24 SUCCEEDED
ASSERTING A32 (#AT :B7 (500 274 0))
ENTERING THEOREM TA-AT
TA-AT SUCCEEDED THNOVAL
ENTERING THEOREM TA-SUPP
TRYING GOAL G33 (#MANIP :TABLE)
G33 FAILED
ASSERTING A34 (#SUPPORT :TABLE :B7)
A34 SUCCEEDED
TRYING GOAL G35 (#CLEARTOP :TABLE)
G35 FAILED
TA-SUPP SUCCEEDED THNOVAL
ENTERING THEOREM TA-CONTAIN
TRYING GOAL G36 (#MANIP :B7)
G36 SUCCEEDED ((#MANIP :B7))
TRYING GOAL G37 (#SUPPORT (THV Y) :B7)
G37 SUCCEEDED ((#SUPPORT :TABLE :B7))
TRYING GOAL G40 (#IS :TABLE #BOX)
G40 FAILED
TRYING GOAL G41 (#CONTAIN (THV Z) :TABLE)
G41 FAILED
G37 FAILED
G36 FAILED
TA-CONTAIN FAILED

A32 SUCCEEDED
TRYING GOAL G42 (#MOVEHAND2 (600 374 200))
ENTERING THEOREM TC-MOVEHAND2
TC-MOVEHAND2 SUCCEEDED THNOVAL
G42 SUCCEEDED (#MOVEHAND2 (600 374 200))
TRYING GOAL G43 (#SUPPORT (THV Y) :B7)
G43 SUCCEEDED ((#SUPPORT :TABLE :B7))
TC-MOVEHAND SUCCEEDED THNOVAL
G21 SUCCEEDED (#MOVEHAND (600 374 200))
TRYING GOAL G44 (#UNGRASP)
ENTERING THEOREM TC-UNGRASP
TRYING GOAL G45 (#GRASPING (THV X))
G45 SUCCEEDED ((#GRASPING :B7))
TRYING GOAL G46 (#SUPPORT ? :B7)
G46 SUCCEEDED ((#SUPPORT :TABLE :B7))
ERASING E47 (#GRASPING :B7)
E47 SUCCEEDED
ASSERTING A50 (#UNGRASP E6 :B7)
A50 SUCCEEDED
TC-UNGRASP SUCCEEDED THNOVAL
G44 SUCCEEDED (#UNGRASP)
TC-PUT SUCCEEDED THNOVAL
G11 SUCCEEDED (#PUT :B7 (500 274 0))
ASSERTING A51 (#GET-RID-OF E4 :B7)
A51 SUCCEEDED
TC-GET-RID-OF SUCCEEDED THNOVAL
G7 SUCCEEDED (#GET-RID-OF :B7)
TRYING GOAL G52 (#SUPPORT :B6 (THNV Y))
G52 FAILED
ASSERTING A53 (#CLEARTOP :B6)
A53 SUCCEEDED
ASSERTING A54 (#CLEARTOP E3 :B6)
A54 SUCCEEDED
TC-CLEARTOP SUCCEEDED THNOVAL
G4 SUCCEEDED (#CLEARTOP :B6)
>>>
LISTENING---> SHOW EVENT E3

E3  (#CLEARTOP E3 :B6)  --  TIME0 TO 3
    E6  (#UNGRASP E6 :B7)  --  TIME2 TO 2
    E4  (#GET-RID-OF E4 :B7)  --  TIME0 TO 3
         E5  (#GRASP E5 :B7)  --  TIME0 TO 1
*
TRYING GOAL G55 (#GRASPING (THNV Y))
G55 FAILED
TRYING GOAL G56 (#MOVEHAND2 (100 440 300))
ENTERING THEOREM TC-MOVEHAND2
TC-MOVEHAND2 SUCCEEDED THNOVAL
G56 SUCCEEDED (#MOVEHAND2 (100 440 300))
ASSERTING A57 (#GRASPING :B6)
A57 SUCCEEDED
ASSERTING A60 (#GRASP E2 :B6)
A60 SUCCEEDED
TC-GRASP SUCCEEDED THNOVAL
G2 SUCCEEDED (#GRASP :B6)
TRYING GOAL G61 (#RAISEHAND)
ENTERING THEOREM TC-RAISEHAND
TRYING GOAL G62 (#MOVEHAND (100 440 1000))
>>>
LISTENING---> TELL PL

(INPUT ACTION THEOREM ASSERTIONS)
WHICH OPTION? ACTION
ON OR OFF? OFF

*
LISTENING---> TELL ACTION (THASSERT)

*
ASSERTING A63 (#AT :B6 (0 300 500))
A63 SUCCEEDED
G62 SUCCEEDED (#MOVEHAND (100 440 1000))
ASSERTING A64 (#RAISEHAND E7)
A64 SUCCEEDED  SUCCEEDED (#RAISEHAND)
ASSERTING A65 (#PICKUP E1 :B6)
A65 SUCCEEDED
TC-PICKUP SUCCEEDED THNOVAL

G1 SUCCEEDED (#PICKUP :B6)
>>>
LISTENING---> SHOW EVENT E1

E1  (#PICKUP E1 :B6)  --  TIME 0 TO 5
    E2  (#GRASP E2 :B6)  --  TIME 0 TO 4
         E3  (#CLEARTOP E3 :B6)  --  TIME 0 TO 3
              E4  (#GET-RID-OF E4 :B7)  --  TIME 0 TO 3
                   E5  (#GRASP E5 :B7)  --  TIME 0 TO 1
              E6  (#UNGRASP E6 :B7)  --  TIME 2 TO 2
    E7  (#RAISEHAND E7)  --  TIME 4 TO 5
(EE LISTENING---> 

[ANS1]
   ACTION=        ((MOVETO 100 340 500) (GRASP ':B7)
                                        (MOVETO 600 374 200)
                                        (UNGRASP)
                                        (MOVETO 100 440 300)
                                        (GRASP ':B6)
                                        (MOVETO 100 440 1000)
                                        (SAY OK))
   ANSRSS=        RSS1
   ANSNODE=       ANS1
   PLAUSIBILITY= 0

*
MOVETO (100 340 500)
GRASP :B7
MOVETO (600 374 200)
UNGRASP
MOVETO (100 440 300)
GRASP :B6
MOVETO (100 440 1000)OK .

APPENDIX 6
----------

THIS SHOWS THE PROCESS OF ADDING WORDS, THEOREMS AND ASSERTIONS
TO SHRDLU'S DATA BASE AND THEIR INTERACTION IN THE UNDERSTANDING
OF NEW SENTENCES.
==================================================================

READY

>>>
LISTENING---> TELL WORD

WORD: SKUNK

NOUN OR VERB? NOUN
MARKERS: (#ANIMAL)

PROCEDURE: ?

LIST OF EXPRESSIONS TO BE PUT IN PLANNER GOALS TO DESCRIBE OBJECT -
USE *** TO REPRESENT OBJECT BEING DESCRIBED BY WORD
PROCEDURE: ((*** #IS-A #SKUNK))

LISTENING---> SHOW WORD SKUNK

[SKUNK]
   SEMANTICS      ((NOUN
                    (OBJECT
                        (MARKERS: (#ANIMAL)
                         PROCEDURE: ((*** #IS-A
                                          #SKUNK))))))
   FEATURES       (NOUN NS)

>>>
LISTENING---> TELL MA

MARKER: #ANIMAL

PARENT: #PHYSOB

*
LISTENING---> TELL WORD ANIMAL

WORD: ANIMAL

NOUN OR VERB? NOUN
MARKERS: (#ANIMAL)

PROCEDURE: ((*** #IS-A #ANIMAL))

>>>
LISTENING---> TELL THEOREM

THEOREM-TYPE: ?

ANTECEDENT, ERASING, OR CONSEQUENT THEOREM
THE CHOICES ARE:
(THANTE THERASING THCONSE)
THEOREM-TYPE: THANTE
VARIABLE-LIST: (X)

PATTERN: ($?X #IS-A #SKUNK)

BODY: ((THASSERT  ($?X #IS-A #ANIMAL)))

*
LISTENING---> SHOW THEOREM THEOREM1

 (THANTE (X)
($?X #IS-A #SKUNK) (THASSERT ($?X #IS-A #ANIMAL)))
*
LISTENING---> TELL PLANNER ON

*
LISTENING---> TELL AS

ASSERTION: (=FLOWER #IS-A #SKUNK)

ASSERTING A66 (=FLOWER #IS-A #SKUNK)
ENTERING THEOREM THEOREM1
ASSERTING A67 (=FLOWER #IS-A #ANIMAL)
A67 SUCCEEDED
THEOREM1 SUCCEEDED THNOVAL
A66 SUCCEEDED
*
LISTENING---> SHOW AS =FLOWER

(((=FLOWER #IS-A #ANIMAL)) ((=FLOWER #IS-A #SKUNK)))
*
LISTENING---> TELL WORD

WORD: STINK

NOUN OR VERB? VERB
MARKERS: (#EVENT)

TRANSITIVE OR INTRANSITIVE? INTRANSITIVE
RESTRICTIONS ON SUBJECT: (#PHYSOB)

LISTENING--->

PROCEDURE:  ?
LIST OF EXPRESSIONS TO BE PUT INTO PLANNER GOALS TO DESCRIBE ACTION
OR RELATION -- USE #1 FOR SUBJECT, #2 FOR OBJECT.
PROCEDURE:  ((#ODERIFEROUS #1))
*
LISTENING---> TELL TELLABLE #ODERIFEROUS

*
LISTENING---> TELL PA OFF

*
LISTENING---> GO
QUIT
READY
ALL SKUNKS STINK.
[1]

[TSS1]
   TSSNODE=       TSS1

>>>
LISTENING---> 

[OSS1]
   OSSNODE=       OSS1
   PARSENODE=     (NODE3)
   VARIABLE=      X1
   DETERMINER=    (NPL NDET NIL)

>>>
LISTENING---> 

[OSS2]
   OSSNODE=       OSS2
   PARSENODE=     (NODE3)
   VARIABLE=      X1
   RELATIONS=     ((OSS1 #IS-A #SKUNK))
   DETERMINER=    (NPL NDET NIL)
   PLAUSIBILITY= 0
   SYSTEMS=       (#PHYSOB #THING #SYSTEMS)
   MARKERS=       (#SYSTEMS #THING #PHYSOB #ANIMAL)

>>>
LISTENING---> 

[TSS2]
   TSSNODE=       TSS2

>>>
LISTENING---> 

[RSS1]
   PARSENODE=     (NODE1)
   RSSNODE=       RSS1
   REL=   OSS2
   VARIABLE=      EVX1
   RELATIONS=     ((#ODERIFEROUS OSS2))
   PLAUSIBILITY= 0
   RELMARKERS=    ((#SYSTEMS #THING #PHYSOB #ANIMAL)
                   (#PHYSOB #THING #SYSTEMS))
   SYSTEMS=       (#SYSTEMS)
   MARKERS=       (#SYSTEMS #EVENT)

>>>
LISTENING---> 

[ANS1]
   ACTION=        ((SAY I UNDERSTAND)
                   (THADD 'THEOREM2 NIL))
   ANSRSS=        RSS1
   ANSNODE=       ANS1
   PLAUSIBILITY= 0

>>>
LISTENING---> SH TH THEOREM2

(THCONSE (X1) (#ODERIFEROUS $?X1)
          (THGOAL ($?X1 #IS-A #SKUNK) (THDBF MUMBLE))

          )
*
LISTENING---> TELL SE

DO SEMANTIC ANALYSIS? YES
SHOW BUILDING OF SEMANTIC STRUCTURES? NO
*
LISTENING---> 
* I UNDERSTAND .

>>>
LISTENING---> 
READY
DOES ANY ANIMAL STINK?

(THAND (THFIND ALL
                $?X2
                (X2)
                (THGOAL ($?X2 #IS-A #ANIMAL) (THDBF MUMBLE))
                (THGOAL (#ODERIFEROUS $?X2) (THDBF MUMBLE)
                                            (THTBF THTRUE)))
        (THPUTPROP 'X2 THVALUE 'BIND))
>>>  FOR PLANNER
LISTENING---> TELL PLANNER ON

*
LISTENING---> 
TRYING GOAL G70 ((THV X2) #IS-A #ANIMAL)
>>>
LISTENING---> 
G70 SUCCEEDED ((=FLOWER #IS-A #ANIMAL))
>>>
LISTENING---> 
TRYING GOAL G71 (#ODERIFEROUS =FLOWER)
>>>
LISTENING---> 
ENTERING THEOREM THEOREM2
TRYING GOAL G72 (=FLOWER #IS-A #SKUNK)
>>>
LISTENING---> 
G72 SUCCEEDED ((=FLOWER #IS-A #SKUNK))
>>>
LISTENING---> 
THEOREM2 SUCCEEDED THNOVAL
G71 SUCCEEDED (#ODERIFEROUS =FLOWER)
>>>
LISTENING---> 
* YES,FLOWER.

ยง anno/winograd/minih

      ****** SHRDLU States and What They Want    *****

READY   (types out READY)
     English sentence ended with punctuation,
        or <alt-mode> <alt-mode> to go to COMMAND
COMMAND  (types out >>>)
     Command terminated by <CR> <CR>
      or T,NIL or <alt>-P to proceed program
      or GO<CR> to prepare for new sentence
      or HELP <CR> for help messages (of which this is one)
REQUEST  (types out request)
   CHOOSE (request ends with ?)
     Enough of any choice to specify it, followed by
          <period>
        or ?<CR> to see information and choices
        or QUIT<CR> to abort command
   SPECIFY   (request ends with :)
     Name or list, ended with <CR>
        or just <LF> for default value (if appropriate)
        or QUIT<CR> to abort command
        or ?<CR> for info
Abbreviate commands by first two letters.

@

ยง anno/winograd/files

********************************************************************************
*
*       This describes the files maintained on the directory SHRDLU which
*          go into making up the Natural Language Understanding system designed
*          by Terry Winograd (currently at Stanford University)
*
*       The files are ordered alphabeticly within the directory, but are
*          described here in related groups, and are listed by the printing
*          routine in similar groups
*
********************************************************************************

-- Files which support the BLOCKS micro-world

  BLOCKP >  Microplanner code for essentially all the functions of the
             BLOCKS world. - there are some supplementary materials at the
             end of the dictionary and data files

  BLOCKL >  LISP code to support the microplanner code of BLOCKS. In particular
             this includes the routine for finding space on an object and
             for maintaining the history list.

  DATA >    The initial contents (assertions) of the BLOCKS world's
             microplanner data base. Plus a few addittional function calls
             for initializing all other aspects of the micro-world.

  PLNR 180  This is a complete EXPR code version of MICROPLANNER. Calls to
             MICROPLANNER in SHRDLU are always done by calling the function
             THVAL2, contained in the semantics files, rather than the usual
             call to THVAL. PLNR 180 can be loaded independantly and run
             as a toplevel MICROPLANNER if desired. A compiled version of
             the files is availlable as PLNR FASL on SHRDLU, and TS PLNR on
             SYS should point to a core dump of a toplevel MICROPLANNER

  THTRAC 18 This is a file of tracing routines designed for tracing opperations
             during the evaluation of MICROPLANNER code

--  Toplevel files for the language understanding system --

  SYSCOM >  Contains the toplevel function SHRDLU as well as usefull extentions
             to LISP, special printing functions, break functions, garbage
             collection functions etc.

  MORPHO >  Does all the morphological analysis required in the system via
             the function ETAOIN which is also the function called by SHRDLU
             to read in a user's sentence from the console.

  SHOW >    This is the "Show - Tell" user package developed for use at a
             workshop at CMU in 1972. It provides a convenient way for a
             largely naieve user to interogate and change the data structures
             used in the system. Consult the MANUAL CMU for further details

  SETUP >   A loose ends file for setting global variables, initializing
             trace routines, and setting up the initial environment. It is
             intended to be the final file read into the system before
             making a core dump.

--  Files concerned with syntax

  PROGMR >  This file contains all the functions that comprise the programmar
             language fro writing grammars. It expects to be entered from a
             toplevel call to PARSE as done in SHRDLU, and executes grammar
             programs via an intermediary function, APPLY-GRAMMAR, to permit
             differing opperations in the cases of compiled and intrepreted
             code.

  GINTER >  "Grammar Interpreter" - Contains the calling sequence for use when
             running an uncompiled grammar. A precompiling pass is necessary
             on grammar functions to remove extra levels of function calls
             and to incorporate the calling program used in GINTER to eliminate
             GOTO's out of scope.

  GRAMAR >  The entire syntactic recognition grammar for the system. See
             A.I. MEMO 282 "Grammar for the People" for comprehensive flowcharts
             of the functions in this file.

  DICTIO >  Specifications and entrys for all of SHRDLU's vocabulary and
             related atomic symbols. This file contains all aspects of their
             definitions: syntax, semantics, macro-expanders, etc.

-- Semantics files --

  SMSPEC >  "Semantic Specialists"  This contains all the functions which know
             how to interpret the syntactic forms that will be found by the
             grammar: noun groups, relative clauses, pronouns, etc.. All calls
             to these functions come from the syntactic routines through the
             function SMCALL which is in PROGMR.

  SMUTIL >  Utility routines used by all the semantic functions for building
             nodes, evaluating definitions, marker checks, backreference maintanence,
             quantifier adjusting, building MIRCOPLANNER code.

  SMASS >   Access functions that are used by the two previous files to grovel
             through their data structures while retaining their perspicuity.

-- Answering --

  NEWANS >  "new answer" Code for finding the answers to questions, absorbing
             new information, and following commands, then fromulating the
             appropriate English answers. This code is extensively interfaced
             with MICROPLANNER.

-- Documentation --

  MANUAL CMU, MANNEW >, HELP DOC, MINIH DOC

            These files are unfortunately all the documentation availlable on the
             care and feeding of the system appart from Winograd's book (which is
             far and away the best reference to the details of its opperation).
             MANUAL CMU, as its name implys, was developed for the workshop at
             CMU and it the most through overall guide. HELP DOC and MINIH DOC
             are essentially excerpts from it which were intended as online references.
             MANNEW is grossly incomplete, but it is also the most up to date, and
             covers initial ussage of hte system.

  .INDEX >  This is a through cross-reference for all the LISP code used in the system.
             It lists functions and variables alphabeticly with listings of their
             interactions with the rest of the code (functions called, variables
             bound ...). Also of interest is the file LISP >, which alphabeticly lists
             all MACLISP functions ever invoked in the code and the functions that they
             were invoked from.

-- At the end of the directory, the files whose first names are "Z" are the origninal
    files of the system circa January 1971. They use the old list oriented data
    structures and are essentially uncommented. However they can often be of use
    when trying to see if alternate formulations of some algorithm were ever
    considered.

